\doxysection{dsa\+::Stack\+Allocator\texorpdfstring{$<$}{<} T, Pool\+Size \texorpdfstring{$>$}{>} Class Template Reference}
\hypertarget{classdsa_1_1_stack_allocator}{}\label{classdsa_1_1_stack_allocator}\index{dsa::StackAllocator$<$ T, PoolSize $>$@{dsa::StackAllocator$<$ T, PoolSize $>$}}


Standard C++ allocator interface using a stack-\/allocated buffer and \doxylink{classdsa_1_1_t_l_s_f}{TLSF}.  




{\ttfamily \#include $<$Stack\+Allocator.\+hpp$>$}



Collaboration diagram for dsa\+::Stack\+Allocator\texorpdfstring{$<$}{<} T, Pool\+Size \texorpdfstring{$>$}{>}\+:
% FIG 0
\doxysubsubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{structdsa_1_1_stack_allocator_1_1rebind}{rebind}}
\begin{DoxyCompactList}\small\item\em Rebind template for allocator compatibility with different types. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Public Types}
\begin{Indent}\textbf{ Standard C++ allocator typedefs}\par
\begin{DoxyCompactItemize}
\item 
using \mbox{\hyperlink{classdsa_1_1_stack_allocator_a722c3db89180b87bb026c2bb707eaf58}{value\+\_\+type}} = T
\begin{DoxyCompactList}\small\item\em Value type. \end{DoxyCompactList}\item 
using \mbox{\hyperlink{classdsa_1_1_stack_allocator_a6f1fb269c9d78e9ff56f7d6ae86b6b5c}{pointer}} = T\texorpdfstring{$\ast$}{*}
\begin{DoxyCompactList}\small\item\em Pointer type. \end{DoxyCompactList}\item 
using \mbox{\hyperlink{classdsa_1_1_stack_allocator_abe1ea1a33539df9b77d2fc492fb2579a}{const\+\_\+pointer}} = const T\texorpdfstring{$\ast$}{*}
\begin{DoxyCompactList}\small\item\em Const pointer type. \end{DoxyCompactList}\item 
using \mbox{\hyperlink{classdsa_1_1_stack_allocator_a7cfbbd4c5842d61d360ba6077a3c3f55}{reference}} = T\&
\begin{DoxyCompactList}\small\item\em Reference type. \end{DoxyCompactList}\item 
using \mbox{\hyperlink{classdsa_1_1_stack_allocator_a1d0e1f9e82764ba5453847c18f4daae3}{const\+\_\+reference}} = const T\&
\begin{DoxyCompactList}\small\item\em Const reference type. \end{DoxyCompactList}\item 
using \mbox{\hyperlink{classdsa_1_1_stack_allocator_a33d07688c2e4c655fb599cfdd11a4f23}{size\+\_\+type}} = size\+\_\+t
\begin{DoxyCompactList}\small\item\em Size type. \end{DoxyCompactList}\item 
using \mbox{\hyperlink{classdsa_1_1_stack_allocator_a3fd2ced1844ada5c0f356f6206feee5b}{difference\+\_\+type}} = ptrdiff\+\_\+t
\begin{DoxyCompactList}\small\item\em Difference type. \end{DoxyCompactList}\end{DoxyCompactItemize}
\end{Indent}
\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classdsa_1_1_stack_allocator_a02f70218d7dfcf43f65c18040be438fa}{Stack\+Allocator}} ()
\begin{DoxyCompactList}\small\item\em Constructor initializes the stack allocator with a fixed-\/size buffer. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename U$>$ }\\\mbox{\hyperlink{classdsa_1_1_stack_allocator_ad4cad2d660493a84da6e0cbc70ca9d7c}{Stack\+Allocator}} (const \mbox{\hyperlink{classdsa_1_1_stack_allocator}{Stack\+Allocator}}$<$ U, Pool\+Size $>$ \&)
\begin{DoxyCompactList}\small\item\em Copy constructor for allocator propagation (required by STL). \end{DoxyCompactList}\item 
\mbox{\hyperlink{classdsa_1_1_stack_allocator_a6f1fb269c9d78e9ff56f7d6ae86b6b5c}{pointer}} \mbox{\hyperlink{classdsa_1_1_stack_allocator_ad6065ffca156daa8261fe82a0d3c6c2d}{allocate}} (\mbox{\hyperlink{classdsa_1_1_stack_allocator_a33d07688c2e4c655fb599cfdd11a4f23}{size\+\_\+type}} n)
\begin{DoxyCompactList}\small\item\em Allocates uninitialized storage for n objects of type T. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classdsa_1_1_stack_allocator_aedb009075f20cb41cad885cc31877a31}{deallocate}} (\mbox{\hyperlink{classdsa_1_1_stack_allocator_a6f1fb269c9d78e9ff56f7d6ae86b6b5c}{pointer}} p, \mbox{\hyperlink{classdsa_1_1_stack_allocator_a33d07688c2e4c655fb599cfdd11a4f23}{size\+\_\+type}})
\begin{DoxyCompactList}\small\item\em Deallocates storage for n objects of type T. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classdsa_1_1_stack_allocator_ab64950648b56eaf85ce57cdbbf4ae268}{construct}} (\mbox{\hyperlink{classdsa_1_1_stack_allocator_a6f1fb269c9d78e9ff56f7d6ae86b6b5c}{pointer}} p, \mbox{\hyperlink{classdsa_1_1_stack_allocator_a1d0e1f9e82764ba5453847c18f4daae3}{const\+\_\+reference}} val)
\begin{DoxyCompactList}\small\item\em Constructs an object of type T at the given memory location. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classdsa_1_1_stack_allocator_a5b845bb8d5c808b958f853e941c7da25}{destroy}} (\mbox{\hyperlink{classdsa_1_1_stack_allocator_a6f1fb269c9d78e9ff56f7d6ae86b6b5c}{pointer}} p)
\begin{DoxyCompactList}\small\item\em Destroys an object of type T at the given memory location. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classdsa_1_1_stack_allocator_a679488c3a2948feece4efcd8f75936ad}{operator==}} (const \mbox{\hyperlink{classdsa_1_1_stack_allocator}{Stack\+Allocator}} \&other) const
\begin{DoxyCompactList}\small\item\em Equality operator\+: compares based on memory pool identity. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classdsa_1_1_stack_allocator_a7f597c8101a4b5b016ab3cb91ce9d484}{operator!=}} (const \mbox{\hyperlink{classdsa_1_1_stack_allocator}{Stack\+Allocator}} \&other) const
\begin{DoxyCompactList}\small\item\em Inequality operator. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classdsa_1_1_stack_allocator_a14665adf09333a2bc2edbcdd98f42b3f}{set\+Lock}} (\mbox{\hyperlink{classelock_1_1_i_lockable}{elock\+::\+ILockable}} \texorpdfstring{$\ast$}{*}lock)
\begin{DoxyCompactList}\small\item\em Sets a lock for thread safety (optional, MCU/host agnostic). \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
char \mbox{\hyperlink{classdsa_1_1_stack_allocator_a14e7b35e7e03104602533f9390aec88a}{memory\+Pool}} \mbox{[}Pool\+Size\mbox{]}
\begin{DoxyCompactList}\small\item\em Stack-\/allocated memory pool. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classdsa_1_1e_alloc}{dsa\+::e\+Alloc}} \mbox{\hyperlink{classdsa_1_1_stack_allocator_a3534fdb042f8df550c4ae6727e600636}{allocator}}
\begin{DoxyCompactList}\small\item\em Internal \doxylink{classdsa_1_1_t_l_s_f}{TLSF} allocator managing the pool. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$typename T, size\+\_\+t Pool\+Size$>$\newline
class dsa\+::\+Stack\+Allocator$<$ T, Pool\+Size $>$}
Standard C++ allocator interface using a stack-\/allocated buffer and \doxylink{classdsa_1_1_t_l_s_f}{TLSF}. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Type of object to allocate. \\
\hline
{\em Pool\+Size} & Size of the internal stack buffer in bytes.\\
\hline
\end{DoxyTemplParams}
Usage\+: \doxylink{classdsa_1_1_stack_allocator}{dsa\+::\+Stack\+Allocator$<$int, 1024$>$} alloc; std\+::vector$<$int, dsa\+::\+Stack\+Allocator$<$int, 1024$>$$>$ v(alloc);

Thread Safety\+:
\begin{DoxyItemize}
\item Not thread-\/safe by default.
\item To enable, call \doxylink{classdsa_1_1_stack_allocator_a14665adf09333a2bc2edbcdd98f42b3f}{set\+Lock()} with a \doxylink{classelock_1_1_i_lockable}{elock\+::\+ILockable}\texorpdfstring{$\ast$}{*} mutex adapter.
\item No STL bloat for MCU\+: lock is optional and not used unless set. 
\end{DoxyItemize}

Definition at line \mbox{\hyperlink{_stack_allocator_8hpp_source_l00033}{33}} of file \mbox{\hyperlink{_stack_allocator_8hpp_source}{Stack\+Allocator.\+hpp}}.



\doxysubsection{Member Typedef Documentation}
\Hypertarget{classdsa_1_1_stack_allocator_abe1ea1a33539df9b77d2fc492fb2579a}\index{dsa::StackAllocator$<$ T, PoolSize $>$@{dsa::StackAllocator$<$ T, PoolSize $>$}!const\_pointer@{const\_pointer}}
\index{const\_pointer@{const\_pointer}!dsa::StackAllocator$<$ T, PoolSize $>$@{dsa::StackAllocator$<$ T, PoolSize $>$}}
\doxysubsubsection{\texorpdfstring{const\_pointer}{const\_pointer}}
{\footnotesize\ttfamily \label{classdsa_1_1_stack_allocator_abe1ea1a33539df9b77d2fc492fb2579a} 
template$<$typename T, size\+\_\+t Pool\+Size$>$ \\
using \mbox{\hyperlink{classdsa_1_1_stack_allocator}{dsa\+::\+Stack\+Allocator}}$<$ T, Pool\+Size $>$\+::const\+\_\+pointer = const T\texorpdfstring{$\ast$}{*}}



Const pointer type. 



Definition at line \mbox{\hyperlink{_stack_allocator_8hpp_source_l00040}{40}} of file \mbox{\hyperlink{_stack_allocator_8hpp_source}{Stack\+Allocator.\+hpp}}.

\Hypertarget{classdsa_1_1_stack_allocator_a1d0e1f9e82764ba5453847c18f4daae3}\index{dsa::StackAllocator$<$ T, PoolSize $>$@{dsa::StackAllocator$<$ T, PoolSize $>$}!const\_reference@{const\_reference}}
\index{const\_reference@{const\_reference}!dsa::StackAllocator$<$ T, PoolSize $>$@{dsa::StackAllocator$<$ T, PoolSize $>$}}
\doxysubsubsection{\texorpdfstring{const\_reference}{const\_reference}}
{\footnotesize\ttfamily \label{classdsa_1_1_stack_allocator_a1d0e1f9e82764ba5453847c18f4daae3} 
template$<$typename T, size\+\_\+t Pool\+Size$>$ \\
using \mbox{\hyperlink{classdsa_1_1_stack_allocator}{dsa\+::\+Stack\+Allocator}}$<$ T, Pool\+Size $>$\+::const\+\_\+reference = const T\&}



Const reference type. 



Definition at line \mbox{\hyperlink{_stack_allocator_8hpp_source_l00042}{42}} of file \mbox{\hyperlink{_stack_allocator_8hpp_source}{Stack\+Allocator.\+hpp}}.

\Hypertarget{classdsa_1_1_stack_allocator_a3fd2ced1844ada5c0f356f6206feee5b}\index{dsa::StackAllocator$<$ T, PoolSize $>$@{dsa::StackAllocator$<$ T, PoolSize $>$}!difference\_type@{difference\_type}}
\index{difference\_type@{difference\_type}!dsa::StackAllocator$<$ T, PoolSize $>$@{dsa::StackAllocator$<$ T, PoolSize $>$}}
\doxysubsubsection{\texorpdfstring{difference\_type}{difference\_type}}
{\footnotesize\ttfamily \label{classdsa_1_1_stack_allocator_a3fd2ced1844ada5c0f356f6206feee5b} 
template$<$typename T, size\+\_\+t Pool\+Size$>$ \\
using \mbox{\hyperlink{classdsa_1_1_stack_allocator}{dsa\+::\+Stack\+Allocator}}$<$ T, Pool\+Size $>$\+::difference\+\_\+type = ptrdiff\+\_\+t}



Difference type. 



Definition at line \mbox{\hyperlink{_stack_allocator_8hpp_source_l00044}{44}} of file \mbox{\hyperlink{_stack_allocator_8hpp_source}{Stack\+Allocator.\+hpp}}.

\Hypertarget{classdsa_1_1_stack_allocator_a6f1fb269c9d78e9ff56f7d6ae86b6b5c}\index{dsa::StackAllocator$<$ T, PoolSize $>$@{dsa::StackAllocator$<$ T, PoolSize $>$}!pointer@{pointer}}
\index{pointer@{pointer}!dsa::StackAllocator$<$ T, PoolSize $>$@{dsa::StackAllocator$<$ T, PoolSize $>$}}
\doxysubsubsection{\texorpdfstring{pointer}{pointer}}
{\footnotesize\ttfamily \label{classdsa_1_1_stack_allocator_a6f1fb269c9d78e9ff56f7d6ae86b6b5c} 
template$<$typename T, size\+\_\+t Pool\+Size$>$ \\
using \mbox{\hyperlink{classdsa_1_1_stack_allocator}{dsa\+::\+Stack\+Allocator}}$<$ T, Pool\+Size $>$\+::pointer = T\texorpdfstring{$\ast$}{*}}



Pointer type. 



Definition at line \mbox{\hyperlink{_stack_allocator_8hpp_source_l00039}{39}} of file \mbox{\hyperlink{_stack_allocator_8hpp_source}{Stack\+Allocator.\+hpp}}.

\Hypertarget{classdsa_1_1_stack_allocator_a7cfbbd4c5842d61d360ba6077a3c3f55}\index{dsa::StackAllocator$<$ T, PoolSize $>$@{dsa::StackAllocator$<$ T, PoolSize $>$}!reference@{reference}}
\index{reference@{reference}!dsa::StackAllocator$<$ T, PoolSize $>$@{dsa::StackAllocator$<$ T, PoolSize $>$}}
\doxysubsubsection{\texorpdfstring{reference}{reference}}
{\footnotesize\ttfamily \label{classdsa_1_1_stack_allocator_a7cfbbd4c5842d61d360ba6077a3c3f55} 
template$<$typename T, size\+\_\+t Pool\+Size$>$ \\
using \mbox{\hyperlink{classdsa_1_1_stack_allocator}{dsa\+::\+Stack\+Allocator}}$<$ T, Pool\+Size $>$\+::reference = T\&}



Reference type. 



Definition at line \mbox{\hyperlink{_stack_allocator_8hpp_source_l00041}{41}} of file \mbox{\hyperlink{_stack_allocator_8hpp_source}{Stack\+Allocator.\+hpp}}.

\Hypertarget{classdsa_1_1_stack_allocator_a33d07688c2e4c655fb599cfdd11a4f23}\index{dsa::StackAllocator$<$ T, PoolSize $>$@{dsa::StackAllocator$<$ T, PoolSize $>$}!size\_type@{size\_type}}
\index{size\_type@{size\_type}!dsa::StackAllocator$<$ T, PoolSize $>$@{dsa::StackAllocator$<$ T, PoolSize $>$}}
\doxysubsubsection{\texorpdfstring{size\_type}{size\_type}}
{\footnotesize\ttfamily \label{classdsa_1_1_stack_allocator_a33d07688c2e4c655fb599cfdd11a4f23} 
template$<$typename T, size\+\_\+t Pool\+Size$>$ \\
using \mbox{\hyperlink{classdsa_1_1_stack_allocator}{dsa\+::\+Stack\+Allocator}}$<$ T, Pool\+Size $>$\+::size\+\_\+type = size\+\_\+t}



Size type. 



Definition at line \mbox{\hyperlink{_stack_allocator_8hpp_source_l00043}{43}} of file \mbox{\hyperlink{_stack_allocator_8hpp_source}{Stack\+Allocator.\+hpp}}.

\Hypertarget{classdsa_1_1_stack_allocator_a722c3db89180b87bb026c2bb707eaf58}\index{dsa::StackAllocator$<$ T, PoolSize $>$@{dsa::StackAllocator$<$ T, PoolSize $>$}!value\_type@{value\_type}}
\index{value\_type@{value\_type}!dsa::StackAllocator$<$ T, PoolSize $>$@{dsa::StackAllocator$<$ T, PoolSize $>$}}
\doxysubsubsection{\texorpdfstring{value\_type}{value\_type}}
{\footnotesize\ttfamily \label{classdsa_1_1_stack_allocator_a722c3db89180b87bb026c2bb707eaf58} 
template$<$typename T, size\+\_\+t Pool\+Size$>$ \\
using \mbox{\hyperlink{classdsa_1_1_stack_allocator}{dsa\+::\+Stack\+Allocator}}$<$ T, Pool\+Size $>$\+::value\+\_\+type = T}



Value type. 



Definition at line \mbox{\hyperlink{_stack_allocator_8hpp_source_l00038}{38}} of file \mbox{\hyperlink{_stack_allocator_8hpp_source}{Stack\+Allocator.\+hpp}}.



\doxysubsection{Constructor \& Destructor Documentation}
\Hypertarget{classdsa_1_1_stack_allocator_a02f70218d7dfcf43f65c18040be438fa}\index{dsa::StackAllocator$<$ T, PoolSize $>$@{dsa::StackAllocator$<$ T, PoolSize $>$}!StackAllocator@{StackAllocator}}
\index{StackAllocator@{StackAllocator}!dsa::StackAllocator$<$ T, PoolSize $>$@{dsa::StackAllocator$<$ T, PoolSize $>$}}
\doxysubsubsection{\texorpdfstring{StackAllocator()}{StackAllocator()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{classdsa_1_1_stack_allocator_a02f70218d7dfcf43f65c18040be438fa} 
template$<$typename T, size\+\_\+t Pool\+Size$>$ \\
\mbox{\hyperlink{classdsa_1_1_stack_allocator}{dsa\+::\+Stack\+Allocator}}$<$ T, Pool\+Size $>$\+::\+Stack\+Allocator (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Constructor initializes the stack allocator with a fixed-\/size buffer. 



Definition at line \mbox{\hyperlink{_stack_allocator_8hpp_source_l00061}{61}} of file \mbox{\hyperlink{_stack_allocator_8hpp_source}{Stack\+Allocator.\+hpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00061\ :\ \mbox{\hyperlink{classdsa_1_1_stack_allocator_a3534fdb042f8df550c4ae6727e600636}{allocator}}(\mbox{\hyperlink{classdsa_1_1_stack_allocator_a14e7b35e7e03104602533f9390aec88a}{memoryPool}},\ \mbox{\hyperlink{classdsa_1_1_stack_allocator}{PoolSize}})\ \{\}}

\end{DoxyCode}
\Hypertarget{classdsa_1_1_stack_allocator_ad4cad2d660493a84da6e0cbc70ca9d7c}\index{dsa::StackAllocator$<$ T, PoolSize $>$@{dsa::StackAllocator$<$ T, PoolSize $>$}!StackAllocator@{StackAllocator}}
\index{StackAllocator@{StackAllocator}!dsa::StackAllocator$<$ T, PoolSize $>$@{dsa::StackAllocator$<$ T, PoolSize $>$}}
\doxysubsubsection{\texorpdfstring{StackAllocator()}{StackAllocator()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{classdsa_1_1_stack_allocator_ad4cad2d660493a84da6e0cbc70ca9d7c} 
template$<$typename T, size\+\_\+t Pool\+Size$>$ \\
template$<$typename U$>$ \\
\mbox{\hyperlink{classdsa_1_1_stack_allocator}{dsa\+::\+Stack\+Allocator}}$<$ T, Pool\+Size $>$\+::\+Stack\+Allocator (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classdsa_1_1_stack_allocator}{Stack\+Allocator}}$<$ U, Pool\+Size $>$ \&}]{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Copy constructor for allocator propagation (required by STL). 


\begin{DoxyTemplParams}{Template Parameters}
{\em U} & Other type for rebind. \\
\hline
\end{DoxyTemplParams}


Definition at line \mbox{\hyperlink{_stack_allocator_8hpp_source_l00068}{68}} of file \mbox{\hyperlink{_stack_allocator_8hpp_source}{Stack\+Allocator.\+hpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00068\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ :\ \mbox{\hyperlink{classdsa_1_1_stack_allocator_a3534fdb042f8df550c4ae6727e600636}{allocator}}(\mbox{\hyperlink{classdsa_1_1_stack_allocator_a14e7b35e7e03104602533f9390aec88a}{memoryPool}},\ \mbox{\hyperlink{classdsa_1_1_stack_allocator}{PoolSize}})}
\DoxyCodeLine{00069\ \ \ \ \ \{}
\DoxyCodeLine{00070\ \ \ \ \ \}}

\end{DoxyCode}


\doxysubsection{Member Function Documentation}
\Hypertarget{classdsa_1_1_stack_allocator_ad6065ffca156daa8261fe82a0d3c6c2d}\index{dsa::StackAllocator$<$ T, PoolSize $>$@{dsa::StackAllocator$<$ T, PoolSize $>$}!allocate@{allocate}}
\index{allocate@{allocate}!dsa::StackAllocator$<$ T, PoolSize $>$@{dsa::StackAllocator$<$ T, PoolSize $>$}}
\doxysubsubsection{\texorpdfstring{allocate()}{allocate()}}
{\footnotesize\ttfamily \label{classdsa_1_1_stack_allocator_ad6065ffca156daa8261fe82a0d3c6c2d} 
template$<$typename T, size\+\_\+t Pool\+Size$>$ \\
\mbox{\hyperlink{classdsa_1_1_stack_allocator_a6f1fb269c9d78e9ff56f7d6ae86b6b5c}{pointer}} \mbox{\hyperlink{classdsa_1_1_stack_allocator}{dsa\+::\+Stack\+Allocator}}$<$ T, Pool\+Size $>$\+::allocate (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classdsa_1_1_stack_allocator_a33d07688c2e4c655fb599cfdd11a4f23}{size\+\_\+type}}}]{n}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Allocates uninitialized storage for n objects of type T. 


\begin{DoxyParams}{Parameters}
{\em n} & Number of objects to allocate. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Pointer to the allocated storage. 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::bad\+\_\+alloc} & if allocation fails. \\
\hline
\end{DoxyExceptions}


Definition at line \mbox{\hyperlink{_stack_allocator_8hpp_source_l00078}{78}} of file \mbox{\hyperlink{_stack_allocator_8hpp_source}{Stack\+Allocator.\+hpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00079\ \ \ \ \ \{}
\DoxyCodeLine{00080\ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{void}*\ \mbox{\hyperlink{classdsa_1_1_stack_allocator}{ptr}}\ =\ \mbox{\hyperlink{classdsa_1_1_stack_allocator_a3534fdb042f8df550c4ae6727e600636}{allocator}}.malloc(\mbox{\hyperlink{classdsa_1_1_stack_allocator}{n}}\ *\ \textcolor{keyword}{sizeof}(\mbox{\hyperlink{classdsa_1_1_stack_allocator}{T}}));}
\DoxyCodeLine{00081\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}(!\mbox{\hyperlink{classdsa_1_1_stack_allocator}{ptr}})}
\DoxyCodeLine{00082\ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00083\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{throw}\ \mbox{\hyperlink{classdsa_1_1_stack_allocator}{std::bad\_alloc}}();}
\DoxyCodeLine{00084\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00085\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{static\_cast<}\mbox{\hyperlink{classdsa_1_1_stack_allocator_a6f1fb269c9d78e9ff56f7d6ae86b6b5c}{pointer}}\textcolor{keyword}{>}(\mbox{\hyperlink{classdsa_1_1_stack_allocator}{ptr}});}
\DoxyCodeLine{00086\ \ \ \ \ \}}

\end{DoxyCode}
\Hypertarget{classdsa_1_1_stack_allocator_ab64950648b56eaf85ce57cdbbf4ae268}\index{dsa::StackAllocator$<$ T, PoolSize $>$@{dsa::StackAllocator$<$ T, PoolSize $>$}!construct@{construct}}
\index{construct@{construct}!dsa::StackAllocator$<$ T, PoolSize $>$@{dsa::StackAllocator$<$ T, PoolSize $>$}}
\doxysubsubsection{\texorpdfstring{construct()}{construct()}}
{\footnotesize\ttfamily \label{classdsa_1_1_stack_allocator_ab64950648b56eaf85ce57cdbbf4ae268} 
template$<$typename T, size\+\_\+t Pool\+Size$>$ \\
void \mbox{\hyperlink{classdsa_1_1_stack_allocator}{dsa\+::\+Stack\+Allocator}}$<$ T, Pool\+Size $>$\+::construct (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classdsa_1_1_stack_allocator_a6f1fb269c9d78e9ff56f7d6ae86b6b5c}{pointer}}}]{p}{, }\item[{\mbox{\hyperlink{classdsa_1_1_stack_allocator_a1d0e1f9e82764ba5453847c18f4daae3}{const\+\_\+reference}}}]{val}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Constructs an object of type T at the given memory location. 


\begin{DoxyParams}{Parameters}
{\em p} & Pointer to memory. \\
\hline
{\em val} & Value to copy-\/construct. \\
\hline
\end{DoxyParams}


Definition at line \mbox{\hyperlink{_stack_allocator_8hpp_source_l00100}{100}} of file \mbox{\hyperlink{_stack_allocator_8hpp_source}{Stack\+Allocator.\+hpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00100\ \{\ \textcolor{keyword}{new}(\mbox{\hyperlink{classdsa_1_1_stack_allocator}{p}})\ \mbox{\hyperlink{classdsa_1_1_stack_allocator}{T}}(\mbox{\hyperlink{classdsa_1_1_stack_allocator}{val}});\ \}}

\end{DoxyCode}
\Hypertarget{classdsa_1_1_stack_allocator_aedb009075f20cb41cad885cc31877a31}\index{dsa::StackAllocator$<$ T, PoolSize $>$@{dsa::StackAllocator$<$ T, PoolSize $>$}!deallocate@{deallocate}}
\index{deallocate@{deallocate}!dsa::StackAllocator$<$ T, PoolSize $>$@{dsa::StackAllocator$<$ T, PoolSize $>$}}
\doxysubsubsection{\texorpdfstring{deallocate()}{deallocate()}}
{\footnotesize\ttfamily \label{classdsa_1_1_stack_allocator_aedb009075f20cb41cad885cc31877a31} 
template$<$typename T, size\+\_\+t Pool\+Size$>$ \\
void \mbox{\hyperlink{classdsa_1_1_stack_allocator}{dsa\+::\+Stack\+Allocator}}$<$ T, Pool\+Size $>$\+::deallocate (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classdsa_1_1_stack_allocator_a6f1fb269c9d78e9ff56f7d6ae86b6b5c}{pointer}}}]{p}{, }\item[{\mbox{\hyperlink{classdsa_1_1_stack_allocator_a33d07688c2e4c655fb599cfdd11a4f23}{size\+\_\+type}}}]{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Deallocates storage for n objects of type T. 


\begin{DoxyParams}{Parameters}
{\em p} & Pointer to the memory to deallocate. \\
\hline
{\em n} & Number of objects (unused, for interface compliance). \\
\hline
\end{DoxyParams}


Definition at line \mbox{\hyperlink{_stack_allocator_8hpp_source_l00093}{93}} of file \mbox{\hyperlink{_stack_allocator_8hpp_source}{Stack\+Allocator.\+hpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00093\ \{\ \mbox{\hyperlink{classdsa_1_1_stack_allocator_a3534fdb042f8df550c4ae6727e600636}{allocator}}.free(\mbox{\hyperlink{classdsa_1_1_stack_allocator}{p}});\ \}}

\end{DoxyCode}
\Hypertarget{classdsa_1_1_stack_allocator_a5b845bb8d5c808b958f853e941c7da25}\index{dsa::StackAllocator$<$ T, PoolSize $>$@{dsa::StackAllocator$<$ T, PoolSize $>$}!destroy@{destroy}}
\index{destroy@{destroy}!dsa::StackAllocator$<$ T, PoolSize $>$@{dsa::StackAllocator$<$ T, PoolSize $>$}}
\doxysubsubsection{\texorpdfstring{destroy()}{destroy()}}
{\footnotesize\ttfamily \label{classdsa_1_1_stack_allocator_a5b845bb8d5c808b958f853e941c7da25} 
template$<$typename T, size\+\_\+t Pool\+Size$>$ \\
void \mbox{\hyperlink{classdsa_1_1_stack_allocator}{dsa\+::\+Stack\+Allocator}}$<$ T, Pool\+Size $>$\+::destroy (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classdsa_1_1_stack_allocator_a6f1fb269c9d78e9ff56f7d6ae86b6b5c}{pointer}}}]{p}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Destroys an object of type T at the given memory location. 


\begin{DoxyParams}{Parameters}
{\em p} & Pointer to object to destroy. \\
\hline
\end{DoxyParams}


Definition at line \mbox{\hyperlink{_stack_allocator_8hpp_source_l00106}{106}} of file \mbox{\hyperlink{_stack_allocator_8hpp_source}{Stack\+Allocator.\+hpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00106\ \{\ \mbox{\hyperlink{classdsa_1_1_stack_allocator}{p}}-\/>\string~T();\ \}}

\end{DoxyCode}
\Hypertarget{classdsa_1_1_stack_allocator_a7f597c8101a4b5b016ab3cb91ce9d484}\index{dsa::StackAllocator$<$ T, PoolSize $>$@{dsa::StackAllocator$<$ T, PoolSize $>$}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!dsa::StackAllocator$<$ T, PoolSize $>$@{dsa::StackAllocator$<$ T, PoolSize $>$}}
\doxysubsubsection{\texorpdfstring{operator"!=()}{operator!=()}}
{\footnotesize\ttfamily \label{classdsa_1_1_stack_allocator_a7f597c8101a4b5b016ab3cb91ce9d484} 
template$<$typename T, size\+\_\+t Pool\+Size$>$ \\
bool \mbox{\hyperlink{classdsa_1_1_stack_allocator}{dsa\+::\+Stack\+Allocator}}$<$ T, Pool\+Size $>$\+::operator!= (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classdsa_1_1_stack_allocator}{Stack\+Allocator}}$<$ T, Pool\+Size $>$ \&}]{other}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Inequality operator. 


\begin{DoxyParams}{Parameters}
{\em other} & Another \doxylink{classdsa_1_1_stack_allocator}{Stack\+Allocator} instance. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if not using the same memory pool. 
\end{DoxyReturn}


Definition at line \mbox{\hyperlink{_stack_allocator_8hpp_source_l00120}{120}} of file \mbox{\hyperlink{_stack_allocator_8hpp_source}{Stack\+Allocator.\+hpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00120\ \{\ \textcolor{keywordflow}{return}\ !(*\textcolor{keyword}{this}\ ==\ \mbox{\hyperlink{classdsa_1_1_stack_allocator}{other}});\ \}}

\end{DoxyCode}
\Hypertarget{classdsa_1_1_stack_allocator_a679488c3a2948feece4efcd8f75936ad}\index{dsa::StackAllocator$<$ T, PoolSize $>$@{dsa::StackAllocator$<$ T, PoolSize $>$}!operator==@{operator==}}
\index{operator==@{operator==}!dsa::StackAllocator$<$ T, PoolSize $>$@{dsa::StackAllocator$<$ T, PoolSize $>$}}
\doxysubsubsection{\texorpdfstring{operator==()}{operator==()}}
{\footnotesize\ttfamily \label{classdsa_1_1_stack_allocator_a679488c3a2948feece4efcd8f75936ad} 
template$<$typename T, size\+\_\+t Pool\+Size$>$ \\
bool \mbox{\hyperlink{classdsa_1_1_stack_allocator}{dsa\+::\+Stack\+Allocator}}$<$ T, Pool\+Size $>$\+::operator== (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classdsa_1_1_stack_allocator}{Stack\+Allocator}}$<$ T, Pool\+Size $>$ \&}]{other}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Equality operator\+: compares based on memory pool identity. 


\begin{DoxyParams}{Parameters}
{\em other} & Another \doxylink{classdsa_1_1_stack_allocator}{Stack\+Allocator} instance. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if using the same memory pool. 
\end{DoxyReturn}


Definition at line \mbox{\hyperlink{_stack_allocator_8hpp_source_l00113}{113}} of file \mbox{\hyperlink{_stack_allocator_8hpp_source}{Stack\+Allocator.\+hpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00113\ \{\ \textcolor{keywordflow}{return}\ \mbox{\hyperlink{classdsa_1_1_stack_allocator_a14e7b35e7e03104602533f9390aec88a}{memoryPool}}\ ==\ \mbox{\hyperlink{classdsa_1_1_stack_allocator}{other}}.\mbox{\hyperlink{classdsa_1_1_stack_allocator_a14e7b35e7e03104602533f9390aec88a}{memoryPool}};\ \}}

\end{DoxyCode}
\Hypertarget{classdsa_1_1_stack_allocator_a14665adf09333a2bc2edbcdd98f42b3f}\index{dsa::StackAllocator$<$ T, PoolSize $>$@{dsa::StackAllocator$<$ T, PoolSize $>$}!setLock@{setLock}}
\index{setLock@{setLock}!dsa::StackAllocator$<$ T, PoolSize $>$@{dsa::StackAllocator$<$ T, PoolSize $>$}}
\doxysubsubsection{\texorpdfstring{setLock()}{setLock()}}
{\footnotesize\ttfamily \label{classdsa_1_1_stack_allocator_a14665adf09333a2bc2edbcdd98f42b3f} 
template$<$typename T, size\+\_\+t Pool\+Size$>$ \\
void \mbox{\hyperlink{classdsa_1_1_stack_allocator}{dsa\+::\+Stack\+Allocator}}$<$ T, Pool\+Size $>$\+::set\+Lock (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classelock_1_1_i_lockable}{elock\+::\+ILockable}} \texorpdfstring{$\ast$}{*}}]{lock}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Sets a lock for thread safety (optional, MCU/host agnostic). 


\begin{DoxyParams}{Parameters}
{\em lock} & Pointer to a \doxylink{classelock_1_1_i_lockable}{elock\+::\+ILockable} mutex adapter.\\
\hline
\end{DoxyParams}
If not set, the allocator is not thread-\/safe. For host builds, use elock\+::\+Std\+Mutex. For embedded, use the appropriate platform adapter. Locking is delegated to \doxylink{classdsa_1_1e_alloc}{e\+Alloc}. 

Definition at line \mbox{\hyperlink{_stack_allocator_8hpp_source_l00129}{129}} of file \mbox{\hyperlink{_stack_allocator_8hpp_source}{Stack\+Allocator.\+hpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00129\ \{\ \mbox{\hyperlink{classdsa_1_1_stack_allocator_a3534fdb042f8df550c4ae6727e600636}{allocator}}.setLock(\mbox{\hyperlink{classdsa_1_1_stack_allocator}{lock}});\ \}}

\end{DoxyCode}


\doxysubsection{Member Data Documentation}
\Hypertarget{classdsa_1_1_stack_allocator_a3534fdb042f8df550c4ae6727e600636}\index{dsa::StackAllocator$<$ T, PoolSize $>$@{dsa::StackAllocator$<$ T, PoolSize $>$}!allocator@{allocator}}
\index{allocator@{allocator}!dsa::StackAllocator$<$ T, PoolSize $>$@{dsa::StackAllocator$<$ T, PoolSize $>$}}
\doxysubsubsection{\texorpdfstring{allocator}{allocator}}
{\footnotesize\ttfamily \label{classdsa_1_1_stack_allocator_a3534fdb042f8df550c4ae6727e600636} 
template$<$typename T, size\+\_\+t Pool\+Size$>$ \\
\mbox{\hyperlink{classdsa_1_1e_alloc}{dsa\+::e\+Alloc}} \mbox{\hyperlink{classdsa_1_1_stack_allocator}{dsa\+::\+Stack\+Allocator}}$<$ T, Pool\+Size $>$\+::allocator\hspace{0.3cm}{\ttfamily [private]}}



Internal \doxylink{classdsa_1_1_t_l_s_f}{TLSF} allocator managing the pool. 



Definition at line \mbox{\hyperlink{_stack_allocator_8hpp_source_l00133}{133}} of file \mbox{\hyperlink{_stack_allocator_8hpp_source}{Stack\+Allocator.\+hpp}}.

\Hypertarget{classdsa_1_1_stack_allocator_a14e7b35e7e03104602533f9390aec88a}\index{dsa::StackAllocator$<$ T, PoolSize $>$@{dsa::StackAllocator$<$ T, PoolSize $>$}!memoryPool@{memoryPool}}
\index{memoryPool@{memoryPool}!dsa::StackAllocator$<$ T, PoolSize $>$@{dsa::StackAllocator$<$ T, PoolSize $>$}}
\doxysubsubsection{\texorpdfstring{memoryPool}{memoryPool}}
{\footnotesize\ttfamily \label{classdsa_1_1_stack_allocator_a14e7b35e7e03104602533f9390aec88a} 
template$<$typename T, size\+\_\+t Pool\+Size$>$ \\
char \mbox{\hyperlink{classdsa_1_1_stack_allocator}{dsa\+::\+Stack\+Allocator}}$<$ T, Pool\+Size $>$\+::memory\+Pool\mbox{[}Pool\+Size\mbox{]}\hspace{0.3cm}{\ttfamily [private]}}



Stack-\/allocated memory pool. 



Definition at line \mbox{\hyperlink{_stack_allocator_8hpp_source_l00132}{132}} of file \mbox{\hyperlink{_stack_allocator_8hpp_source}{Stack\+Allocator.\+hpp}}.



Referenced by \mbox{\hyperlink{_stack_allocator_8hpp_source_l00113}{dsa\+::\+Stack\+Allocator$<$ U, Pool\+Size $>$\+::operator==()}}.



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
src/\mbox{\hyperlink{_stack_allocator_8hpp}{Stack\+Allocator.\+hpp}}\end{DoxyCompactItemize}
