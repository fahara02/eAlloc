<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.13.2" xml:lang="en-US">
  <compounddef id="classdsa_1_1_t_l_s_f" kind="class" language="C++" prot="public">
    <compoundname>dsa::TLSF</compoundname>
    <includes refid="tlsf_8hpp" local="no">tlsf.hpp</includes>
    <innerclass refid="structdsa_1_1_t_l_s_f_1_1_block_header" prot="public">dsa::TLSF::BlockHeader</innerclass>
    <innerclass refid="structdsa_1_1_t_l_s_f_1_1_control" prot="public">dsa::TLSF::Control</innerclass>
    <innerclass refid="structdsa_1_1_t_l_s_f_1_1_second_level" prot="public">dsa::TLSF::SecondLevel</innerclass>
    <templateparamlist>
      <param>
        <type>size_t</type>
        <declname>SLI</declname>
        <defname>SLI</defname>
        <defval>5</defval>
      </param>
    </templateparamlist>
    <sectiondef kind="public-type">
      <memberdef kind="typedef" id="classdsa_1_1_t_l_s_f_1a87a00ee083c05e19c43adac02c5d2c26" prot="public" static="no">
        <type>ptrdiff_t</type>
        <definition>typedef ptrdiff_t dsa::TLSF&lt; SLI &gt;::tlsfptr_t</definition>
        <argsstring></argsstring>
        <name>tlsfptr_t</name>
        <qualifiedname>dsa::TLSF::tlsfptr_t</qualifiedname>
        <briefdescription>
<para>Type for pointer arithmetic. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="123" column="23" bodyfile="src/tlsf.hpp" bodystart="123" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classdsa_1_1_t_l_s_f_1ac2e907fdaba5c8fc4c9185a632d8efe6" prot="public" static="no">
        <type>void(*</type>
        <definition>typedef void(* dsa::TLSF&lt; SLI &gt;::tlsf_walker) (void *ptr, size_t size, int used, void *user)</definition>
        <argsstring>)(void *ptr, size_t size, int used, void *user)</argsstring>
        <name>tlsf_walker</name>
        <qualifiedname>dsa::TLSF::tlsf_walker</qualifiedname>
        <briefdescription>
<para>Function pointer type for walking memory blocks. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="124" column="13" bodyfile="src/tlsf.hpp" bodystart="124" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="private-static-attrib">
      <memberdef kind="variable" id="classdsa_1_1_t_l_s_f_1a7f65c711cb6725696970774320d73895" prot="private" static="yes" constexpr="yes" mutable="no">
        <type>size_t</type>
        <definition>size_t dsa::TLSF&lt; SLI &gt;::SL_INDEX_LOG2</definition>
        <argsstring></argsstring>
        <name>SL_INDEX_LOG2</name>
        <qualifiedname>dsa::TLSF::SL_INDEX_LOG2</qualifiedname>
        <initializer>= SLI</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="61" column="29" bodyfile="src/tlsf.hpp" bodystart="61" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classdsa_1_1_t_l_s_f_1ab129613ed2f692569608a6e438c60d43" prot="private" static="yes" constexpr="yes" mutable="no">
        <type>size_t</type>
        <definition>size_t dsa::TLSF&lt; SLI &gt;::ALIGN_SIZE_LOG2</definition>
        <argsstring></argsstring>
        <name>ALIGN_SIZE_LOG2</name>
        <qualifiedname>dsa::TLSF::ALIGN_SIZE_LOG2</qualifiedname>
        <initializer>= 2</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="62" column="29" bodyfile="src/tlsf.hpp" bodystart="62" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classdsa_1_1_t_l_s_f_1a882d30dfb67c91f27dffe235be08421b" prot="private" static="yes" constexpr="yes" mutable="no">
        <type>size_t</type>
        <definition>size_t dsa::TLSF&lt; SLI &gt;::BLOCK_ALIGNMENT</definition>
        <argsstring></argsstring>
        <name>BLOCK_ALIGNMENT</name>
        <qualifiedname>dsa::TLSF::BLOCK_ALIGNMENT</qualifiedname>
        <initializer>= (1 &lt;&lt; <ref refid="classdsa_1_1_t_l_s_f_1ab129613ed2f692569608a6e438c60d43" kindref="member">ALIGN_SIZE_LOG2</ref>)</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="63" column="29" bodyfile="src/tlsf.hpp" bodystart="63" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classdsa_1_1_t_l_s_f_1aca7f46fa2019c78935d41e6b70576285" prot="private" static="yes" constexpr="yes" mutable="no">
        <type>size_t</type>
        <definition>size_t dsa::TLSF&lt; SLI &gt;::FL_INDEX_MAX</definition>
        <argsstring></argsstring>
        <name>FL_INDEX_MAX</name>
        <qualifiedname>dsa::TLSF::FL_INDEX_MAX</qualifiedname>
        <initializer>= 31</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="64" column="29" bodyfile="src/tlsf.hpp" bodystart="64" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classdsa_1_1_t_l_s_f_1a7c40f02bc93658db4abe068103a35db5" prot="private" static="yes" constexpr="yes" mutable="no">
        <type>size_t</type>
        <definition>size_t dsa::TLSF&lt; SLI &gt;::SLI_COUNT</definition>
        <argsstring></argsstring>
        <name>SLI_COUNT</name>
        <qualifiedname>dsa::TLSF::SLI_COUNT</qualifiedname>
        <initializer>= (1 &lt;&lt; <ref refid="classdsa_1_1_t_l_s_f_1a7f65c711cb6725696970774320d73895" kindref="member">SL_INDEX_LOG2</ref>)</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="65" column="29" bodyfile="src/tlsf.hpp" bodystart="65" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classdsa_1_1_t_l_s_f_1a8d8e01ead196273867c2b41e8927ca76" prot="private" static="yes" constexpr="yes" mutable="no">
        <type>size_t</type>
        <definition>size_t dsa::TLSF&lt; SLI &gt;::FL_INDEX_SHIFT</definition>
        <argsstring></argsstring>
        <name>FL_INDEX_SHIFT</name>
        <qualifiedname>dsa::TLSF::FL_INDEX_SHIFT</qualifiedname>
        <initializer>= (<ref refid="classdsa_1_1_t_l_s_f_1a7f65c711cb6725696970774320d73895" kindref="member">SL_INDEX_LOG2</ref> + <ref refid="classdsa_1_1_t_l_s_f_1ab129613ed2f692569608a6e438c60d43" kindref="member">ALIGN_SIZE_LOG2</ref>)</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="66" column="29" bodyfile="src/tlsf.hpp" bodystart="66" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classdsa_1_1_t_l_s_f_1a4a3f725786424821919caeda3fc46c31" prot="private" static="yes" constexpr="yes" mutable="no">
        <type>size_t</type>
        <definition>size_t dsa::TLSF&lt; SLI &gt;::FL_INDEX_COUNT</definition>
        <argsstring></argsstring>
        <name>FL_INDEX_COUNT</name>
        <qualifiedname>dsa::TLSF::FL_INDEX_COUNT</qualifiedname>
        <initializer>= (<ref refid="classdsa_1_1_t_l_s_f_1aca7f46fa2019c78935d41e6b70576285" kindref="member">FL_INDEX_MAX</ref> - <ref refid="classdsa_1_1_t_l_s_f_1a8d8e01ead196273867c2b41e8927ca76" kindref="member">FL_INDEX_SHIFT</ref> + 1)</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="67" column="29" bodyfile="src/tlsf.hpp" bodystart="67" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classdsa_1_1_t_l_s_f_1ac3ccc1c32d236a03bb2f0382b59557fd" prot="private" static="yes" constexpr="yes" mutable="no">
        <type>size_t</type>
        <definition>size_t dsa::TLSF&lt; SLI &gt;::SMALL_BLOCK_SIZE</definition>
        <argsstring></argsstring>
        <name>SMALL_BLOCK_SIZE</name>
        <qualifiedname>dsa::TLSF::SMALL_BLOCK_SIZE</qualifiedname>
        <initializer>= (1 &lt;&lt; <ref refid="classdsa_1_1_t_l_s_f_1a8d8e01ead196273867c2b41e8927ca76" kindref="member">FL_INDEX_SHIFT</ref>)</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="68" column="29" bodyfile="src/tlsf.hpp" bodystart="68" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classdsa_1_1_t_l_s_f_1a9e9ae52d67bb0faf1920c4c4b8376adc" prot="private" static="yes" constexpr="yes" mutable="no">
        <type>size_t</type>
        <definition>size_t dsa::TLSF&lt; SLI &gt;::ALIGN_SIZE</definition>
        <argsstring></argsstring>
        <name>ALIGN_SIZE</name>
        <qualifiedname>dsa::TLSF::ALIGN_SIZE</qualifiedname>
        <initializer>= <ref refid="classdsa_1_1_t_l_s_f_1a882d30dfb67c91f27dffe235be08421b" kindref="member">BLOCK_ALIGNMENT</ref></initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="69" column="29" bodyfile="src/tlsf.hpp" bodystart="69" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classdsa_1_1_t_l_s_f_1a03169d6bc1a82126fb21b79025546622" prot="private" static="yes" constexpr="yes" mutable="no">
        <type>size_t</type>
        <definition>size_t dsa::TLSF&lt; SLI &gt;::free_bit</definition>
        <argsstring></argsstring>
        <name>free_bit</name>
        <qualifiedname>dsa::TLSF::free_bit</qualifiedname>
        <initializer>= 1 &lt;&lt; 0</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="76" column="29" bodyfile="src/tlsf.hpp" bodystart="76" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classdsa_1_1_t_l_s_f_1aa8384db13c8af386f1d045f57c4ab2a2" prot="private" static="yes" constexpr="yes" mutable="no">
        <type>size_t</type>
        <definition>size_t dsa::TLSF&lt; SLI &gt;::prev_free_bit</definition>
        <argsstring></argsstring>
        <name>prev_free_bit</name>
        <qualifiedname>dsa::TLSF::prev_free_bit</qualifiedname>
        <initializer>= 1 &lt;&lt; 1</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="77" column="29" bodyfile="src/tlsf.hpp" bodystart="77" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classdsa_1_1_t_l_s_f_1ae5fb2e3596c3c6e5b158f1ea583b57ad" prot="private" static="yes" constexpr="yes" mutable="no">
        <type>size_t</type>
        <definition>size_t dsa::TLSF&lt; SLI &gt;::flag_mask</definition>
        <argsstring></argsstring>
        <name>flag_mask</name>
        <qualifiedname>dsa::TLSF::flag_mask</qualifiedname>
        <initializer>= <ref refid="classdsa_1_1_t_l_s_f_1aa8384db13c8af386f1d045f57c4ab2a2" kindref="member">prev_free_bit</ref> | <ref refid="classdsa_1_1_t_l_s_f_1a03169d6bc1a82126fb21b79025546622" kindref="member">free_bit</ref></initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="78" column="29" bodyfile="src/tlsf.hpp" bodystart="78" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classdsa_1_1_t_l_s_f_1a06de927aa2f1743e93856f9429881a03" prot="private" static="yes" constexpr="yes" mutable="no">
        <type>size_t</type>
        <definition>size_t dsa::TLSF&lt; SLI &gt;::block_header_overhead</definition>
        <argsstring></argsstring>
        <name>block_header_overhead</name>
        <qualifiedname>dsa::TLSF::block_header_overhead</qualifiedname>
        <initializer>= sizeof(size_t)</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="80" column="29" bodyfile="src/tlsf.hpp" bodystart="80" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classdsa_1_1_t_l_s_f_1ad0a3c2a58f2ac0c556c0e826b310f0e7" prot="private" static="yes" constexpr="yes" mutable="no">
        <type>size_t</type>
        <definition>size_t dsa::TLSF&lt; SLI &gt;::block_start_offset</definition>
        <argsstring></argsstring>
        <name>block_start_offset</name>
        <qualifiedname>dsa::TLSF::block_start_offset</qualifiedname>
        <initializer>=
        offsetof(<ref refid="structdsa_1_1_t_l_s_f_1_1_block_header" kindref="compound">BlockHeader</ref>, size_and_flags) + <ref refid="classdsa_1_1_t_l_s_f_1a06de927aa2f1743e93856f9429881a03" kindref="member">block_header_overhead</ref></initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="81" column="29" bodyfile="src/tlsf.hpp" bodystart="81" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classdsa_1_1_t_l_s_f_1ac4268e5c889fdf4b4781cf7d7e113464" prot="private" static="yes" constexpr="yes" mutable="no">
        <type>size_t</type>
        <definition>size_t dsa::TLSF&lt; SLI &gt;::block_size_min</definition>
        <argsstring></argsstring>
        <name>block_size_min</name>
        <qualifiedname>dsa::TLSF::block_size_min</qualifiedname>
        <initializer>= sizeof(<ref refid="structdsa_1_1_t_l_s_f_1_1_block_header" kindref="compound">BlockHeader</ref>) - sizeof(<ref refid="structdsa_1_1_t_l_s_f_1_1_block_header" kindref="compound">BlockHeader</ref>*)</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="83" column="29" bodyfile="src/tlsf.hpp" bodystart="83" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classdsa_1_1_t_l_s_f_1a53417c63ebdd45bcc2f4955856929444" prot="private" static="yes" constexpr="yes" mutable="no">
        <type>size_t</type>
        <definition>size_t dsa::TLSF&lt; SLI &gt;::block_size_max</definition>
        <argsstring></argsstring>
        <name>block_size_max</name>
        <qualifiedname>dsa::TLSF::block_size_max</qualifiedname>
        <initializer>= static_cast&lt;size_t&gt;(1 &lt;&lt; <ref refid="classdsa_1_1_t_l_s_f_1aca7f46fa2019c78935d41e6b70576285" kindref="member">FL_INDEX_MAX</ref>)</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="84" column="29" bodyfile="src/tlsf.hpp" bodystart="84" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="public-static-func">
      <memberdef kind="function" id="classdsa_1_1_t_l_s_f_1aa3b06851f567dc4366f71faf793d278c" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>static size_t dsa::TLSF&lt; SLI &gt;::get_size</definition>
        <argsstring>(const BlockHeader *block)</argsstring>
        <name>get_size</name>
        <qualifiedname>dsa::TLSF::get_size</qualifiedname>
        <param>
          <type>const <ref refid="structdsa_1_1_t_l_s_f_1_1_block_header" kindref="compound">BlockHeader</ref> *</type>
          <declname>block</declname>
        </param>
        <briefdescription>
<para>Gets the usable size of a block. </para>
        </briefdescription>
        <detaileddescription>
<para>This function returns the block size after masking out the flag bits.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>block</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the block header. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The size of the block. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="138" column="26" bodyfile="src/tlsf.hpp" bodystart="138" bodyend="141"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1_t_l_s_f_1af56ea62a64a94a3620be635004a433b4" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>static void dsa::TLSF&lt; SLI &gt;::set_size</definition>
        <argsstring>(BlockHeader *block, size_t size)</argsstring>
        <name>set_size</name>
        <qualifiedname>dsa::TLSF::set_size</qualifiedname>
        <param>
          <type><ref refid="structdsa_1_1_t_l_s_f_1_1_block_header" kindref="compound">BlockHeader</ref> *</type>
          <declname>block</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>size</declname>
        </param>
        <briefdescription>
<para>Sets the size of a block while preserving flag bits. </para>
        </briefdescription>
        <detaileddescription>
<para>This function assigns the given size to the block header, preserving the current flag bits.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>block</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the block header. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>New size to set. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="151" column="24" bodyfile="src/tlsf.hpp" bodystart="151" bodyend="154"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1_t_l_s_f_1a1c60aa4b3b12526b95628d9dba0c95be" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>static bool dsa::TLSF&lt; SLI &gt;::is_free</definition>
        <argsstring>(const BlockHeader *block)</argsstring>
        <name>is_free</name>
        <qualifiedname>dsa::TLSF::is_free</qualifiedname>
        <param>
          <type>const <ref refid="structdsa_1_1_t_l_s_f_1_1_block_header" kindref="compound">BlockHeader</ref> *</type>
          <declname>block</declname>
        </param>
        <briefdescription>
<para>Checks if a block is free. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>block</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the block header. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>True if the block is free, false otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="162" column="24" bodyfile="src/tlsf.hpp" bodystart="162" bodyend="165"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1_t_l_s_f_1ac45a129e8e6228e0360fbc191652e9a6" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>static bool dsa::TLSF&lt; SLI &gt;::is_prev_free</definition>
        <argsstring>(const BlockHeader *block)</argsstring>
        <name>is_prev_free</name>
        <qualifiedname>dsa::TLSF::is_prev_free</qualifiedname>
        <param>
          <type>const <ref refid="structdsa_1_1_t_l_s_f_1_1_block_header" kindref="compound">BlockHeader</ref> *</type>
          <declname>block</declname>
        </param>
        <briefdescription>
<para>Checks if the previous block is free. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>block</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the block header. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>True if the previous block is free, false otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="173" column="24" bodyfile="src/tlsf.hpp" bodystart="173" bodyend="176"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1_t_l_s_f_1adcbc2cc8ec2a8e348b2f7c12fb74c013" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>static bool dsa::TLSF&lt; SLI &gt;::is_last</definition>
        <argsstring>(const BlockHeader *block)</argsstring>
        <name>is_last</name>
        <qualifiedname>dsa::TLSF::is_last</qualifiedname>
        <param>
          <type>const <ref refid="structdsa_1_1_t_l_s_f_1_1_block_header" kindref="compound">BlockHeader</ref> *</type>
          <declname>block</declname>
        </param>
        <briefdescription>
<para>Checks if the block is the last block in the heap. </para>
        </briefdescription>
        <detaileddescription>
<para>This is determined by checking if the block size is zero.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>block</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the block header. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>True if the block is the last block, false otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="186" column="24" bodyfile="src/tlsf.hpp" bodystart="186" bodyend="186"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1_t_l_s_f_1a5b817e5a0872cac294950e321bdf75ea" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>static void dsa::TLSF&lt; SLI &gt;::set_free</definition>
        <argsstring>(BlockHeader *block)</argsstring>
        <name>set_free</name>
        <qualifiedname>dsa::TLSF::set_free</qualifiedname>
        <param>
          <type><ref refid="structdsa_1_1_t_l_s_f_1_1_block_header" kindref="compound">BlockHeader</ref> *</type>
          <declname>block</declname>
        </param>
        <briefdescription>
<para>Marks the block as free. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>block</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the block header. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="193" column="24" bodyfile="src/tlsf.hpp" bodystart="193" bodyend="193"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1_t_l_s_f_1a72f2bfdf752ce60b3af7301ea029bffb" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>static void dsa::TLSF&lt; SLI &gt;::set_used</definition>
        <argsstring>(BlockHeader *block)</argsstring>
        <name>set_used</name>
        <qualifiedname>dsa::TLSF::set_used</qualifiedname>
        <param>
          <type><ref refid="structdsa_1_1_t_l_s_f_1_1_block_header" kindref="compound">BlockHeader</ref> *</type>
          <declname>block</declname>
        </param>
        <briefdescription>
<para>Marks the block as used. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>block</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the block header. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="200" column="24" bodyfile="src/tlsf.hpp" bodystart="200" bodyend="200"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1_t_l_s_f_1a8fa3eb30d8636dfb48c02ca7860ec733" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>static void dsa::TLSF&lt; SLI &gt;::set_prev_free</definition>
        <argsstring>(BlockHeader *block)</argsstring>
        <name>set_prev_free</name>
        <qualifiedname>dsa::TLSF::set_prev_free</qualifiedname>
        <param>
          <type><ref refid="structdsa_1_1_t_l_s_f_1_1_block_header" kindref="compound">BlockHeader</ref> *</type>
          <declname>block</declname>
        </param>
        <briefdescription>
<para>Marks the previous block as free. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>block</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the block header. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="207" column="24" bodyfile="src/tlsf.hpp" bodystart="207" bodyend="207"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1_t_l_s_f_1a4fd943d469f8d3be81ba66e109f8340f" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>static void dsa::TLSF&lt; SLI &gt;::set_prev_used</definition>
        <argsstring>(BlockHeader *block)</argsstring>
        <name>set_prev_used</name>
        <qualifiedname>dsa::TLSF::set_prev_used</qualifiedname>
        <param>
          <type><ref refid="structdsa_1_1_t_l_s_f_1_1_block_header" kindref="compound">BlockHeader</ref> *</type>
          <declname>block</declname>
        </param>
        <briefdescription>
<para>Marks the previous block as used. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>block</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the block header. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="214" column="24" bodyfile="src/tlsf.hpp" bodystart="214" bodyend="217"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1_t_l_s_f_1ad3c09c50acbdbcd39ce1ef322b589392" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>const void *</type>
        <definition>static const void * dsa::TLSF&lt; SLI &gt;::to_ptr</definition>
        <argsstring>(const BlockHeader *block)</argsstring>
        <name>to_ptr</name>
        <qualifiedname>dsa::TLSF::to_ptr</qualifiedname>
        <param>
          <type>const <ref refid="structdsa_1_1_t_l_s_f_1_1_block_header" kindref="compound">BlockHeader</ref> *</type>
          <declname>block</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="219" column="30" bodyfile="src/tlsf.hpp" bodystart="219" bodyend="223"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1_t_l_s_f_1a695ec978573cffb0ab2b9d9e28068e02" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void *</type>
        <definition>static void * dsa::TLSF&lt; SLI &gt;::to_ptr_nc</definition>
        <argsstring>(BlockHeader *block)</argsstring>
        <name>to_ptr_nc</name>
        <qualifiedname>dsa::TLSF::to_ptr_nc</qualifiedname>
        <param>
          <type><ref refid="structdsa_1_1_t_l_s_f_1_1_block_header" kindref="compound">BlockHeader</ref> *</type>
          <declname>block</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="224" column="24" bodyfile="src/tlsf.hpp" bodystart="224" bodyend="228"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1_t_l_s_f_1a0d8439adae15c9e8c26088702bcd3561" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>const <ref refid="structdsa_1_1_t_l_s_f_1_1_block_header" kindref="compound">BlockHeader</ref> *</type>
        <definition>static const BlockHeader * dsa::TLSF&lt; SLI &gt;::from_ptr</definition>
        <argsstring>(const void *ptr)</argsstring>
        <name>from_ptr</name>
        <qualifiedname>dsa::TLSF::from_ptr</qualifiedname>
        <param>
          <type>const void *</type>
          <declname>ptr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="229" column="37" bodyfile="src/tlsf.hpp" bodystart="229" bodyend="233"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1_t_l_s_f_1afd2921b2dac73664c9bdadff7abd6eb6" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="structdsa_1_1_t_l_s_f_1_1_block_header" kindref="compound">BlockHeader</ref> *</type>
        <definition>static BlockHeader * dsa::TLSF&lt; SLI &gt;::from_ptr_nc</definition>
        <argsstring>(void *ptr)</argsstring>
        <name>from_ptr_nc</name>
        <qualifiedname>dsa::TLSF::from_ptr_nc</qualifiedname>
        <param>
          <type>void *</type>
          <declname>ptr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="234" column="31" bodyfile="src/tlsf.hpp" bodystart="234" bodyend="238"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1_t_l_s_f_1aed92fd15dfab650b5f73f49b3ec02069" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>const <ref refid="structdsa_1_1_t_l_s_f_1_1_block_header" kindref="compound">BlockHeader</ref> *</type>
        <definition>static const BlockHeader * dsa::TLSF&lt; SLI &gt;::offset_to_block</definition>
        <argsstring>(const void *ptr, size_t size)</argsstring>
        <name>offset_to_block</name>
        <qualifiedname>dsa::TLSF::offset_to_block</qualifiedname>
        <param>
          <type>const void *</type>
          <declname>ptr</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>size</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="241" column="37" bodyfile="src/tlsf.hpp" bodystart="241" bodyend="244"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1_t_l_s_f_1abc81913bafee4d307d838896319a0ca1" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="structdsa_1_1_t_l_s_f_1_1_block_header" kindref="compound">BlockHeader</ref> *</type>
        <definition>static BlockHeader * dsa::TLSF&lt; SLI &gt;::offset_to_block_nc</definition>
        <argsstring>(void *ptr, size_t size)</argsstring>
        <name>offset_to_block_nc</name>
        <qualifiedname>dsa::TLSF::offset_to_block_nc</qualifiedname>
        <param>
          <type>void *</type>
          <declname>ptr</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>size</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="245" column="31" bodyfile="src/tlsf.hpp" bodystart="245" bodyend="248"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1_t_l_s_f_1a916561111ba5eefbd3fb72dba5232bfc" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="structdsa_1_1_t_l_s_f_1_1_block_header" kindref="compound">BlockHeader</ref> *</type>
        <definition>static BlockHeader * dsa::TLSF&lt; SLI &gt;::prev</definition>
        <argsstring>(const BlockHeader *block)</argsstring>
        <name>prev</name>
        <qualifiedname>dsa::TLSF::prev</qualifiedname>
        <param>
          <type>const <ref refid="structdsa_1_1_t_l_s_f_1_1_block_header" kindref="compound">BlockHeader</ref> *</type>
          <declname>block</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="251" column="31" bodyfile="src/tlsf.hpp" bodystart="251" bodyend="255"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1_t_l_s_f_1a95fb2325991390b7e21889d5f212e231" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="structdsa_1_1_t_l_s_f_1_1_block_header" kindref="compound">BlockHeader</ref> *</type>
        <definition>static BlockHeader * dsa::TLSF&lt; SLI &gt;::next</definition>
        <argsstring>(BlockHeader *block)</argsstring>
        <name>next</name>
        <qualifiedname>dsa::TLSF::next</qualifiedname>
        <param>
          <type><ref refid="structdsa_1_1_t_l_s_f_1_1_block_header" kindref="compound">BlockHeader</ref> *</type>
          <declname>block</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="258" column="31" bodyfile="src/tlsf.hpp" bodystart="258" bodyend="264"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1_t_l_s_f_1ad8b1895322339e22c5206069f2bb5300" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>const <ref refid="structdsa_1_1_t_l_s_f_1_1_block_header" kindref="compound">BlockHeader</ref> *</type>
        <definition>static const BlockHeader * dsa::TLSF&lt; SLI &gt;::next_const</definition>
        <argsstring>(const BlockHeader *block)</argsstring>
        <name>next_const</name>
        <qualifiedname>dsa::TLSF::next_const</qualifiedname>
        <param>
          <type>const <ref refid="structdsa_1_1_t_l_s_f_1_1_block_header" kindref="compound">BlockHeader</ref> *</type>
          <declname>block</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="268" column="37" bodyfile="src/tlsf.hpp" bodystart="268" bodyend="274"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1_t_l_s_f_1ab7f459a80a15779948a5b3436caa0fb2" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="structdsa_1_1_t_l_s_f_1_1_block_header" kindref="compound">BlockHeader</ref> *</type>
        <definition>static BlockHeader * dsa::TLSF&lt; SLI &gt;::link_next</definition>
        <argsstring>(BlockHeader *block)</argsstring>
        <name>link_next</name>
        <qualifiedname>dsa::TLSF::link_next</qualifiedname>
        <param>
          <type><ref refid="structdsa_1_1_t_l_s_f_1_1_block_header" kindref="compound">BlockHeader</ref> *</type>
          <declname>block</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="277" column="31" bodyfile="src/tlsf.hpp" bodystart="277" bodyend="282"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1_t_l_s_f_1a32b002299d6d511cfd4db6d6793d2a28" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>static void dsa::TLSF&lt; SLI &gt;::mark_as_free</definition>
        <argsstring>(BlockHeader *block)</argsstring>
        <name>mark_as_free</name>
        <qualifiedname>dsa::TLSF::mark_as_free</qualifiedname>
        <param>
          <type><ref refid="structdsa_1_1_t_l_s_f_1_1_block_header" kindref="compound">BlockHeader</ref> *</type>
          <declname>block</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="286" column="24" bodyfile="src/tlsf.hpp" bodystart="286" bodyend="292"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1_t_l_s_f_1a835dfcb50f18445e12725900519e3d12" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>static void dsa::TLSF&lt; SLI &gt;::mark_as_used</definition>
        <argsstring>(BlockHeader *block)</argsstring>
        <name>mark_as_used</name>
        <qualifiedname>dsa::TLSF::mark_as_used</qualifiedname>
        <param>
          <type><ref refid="structdsa_1_1_t_l_s_f_1_1_block_header" kindref="compound">BlockHeader</ref> *</type>
          <declname>block</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="296" column="24" bodyfile="src/tlsf.hpp" bodystart="296" bodyend="301"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1_t_l_s_f_1afa49f068970ffe8c065baf6b112c7c32" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>static size_t dsa::TLSF&lt; SLI &gt;::align_up</definition>
        <argsstring>(size_t x, size_t align)</argsstring>
        <name>align_up</name>
        <qualifiedname>dsa::TLSF::align_up</qualifiedname>
        <param>
          <type>size_t</type>
          <declname>x</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>align</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="305" column="26" bodyfile="src/tlsf.hpp" bodystart="305" bodyend="309"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1_t_l_s_f_1adbb8bb2285eca7f84e3529b4207215d1" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>static size_t dsa::TLSF&lt; SLI &gt;::align_down</definition>
        <argsstring>(size_t x, size_t align)</argsstring>
        <name>align_down</name>
        <qualifiedname>dsa::TLSF::align_down</qualifiedname>
        <param>
          <type>size_t</type>
          <declname>x</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>align</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="313" column="26" bodyfile="src/tlsf.hpp" bodystart="313" bodyend="317"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1_t_l_s_f_1a7c1da7e5d6c2006a19c5692c8813fdd1" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void *</type>
        <definition>static void * dsa::TLSF&lt; SLI &gt;::align_ptr</definition>
        <argsstring>(const void *ptr, size_t align)</argsstring>
        <name>align_ptr</name>
        <qualifiedname>dsa::TLSF::align_ptr</qualifiedname>
        <param>
          <type>const void *</type>
          <declname>ptr</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>align</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="321" column="24" bodyfile="src/tlsf.hpp" bodystart="321" bodyend="326"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1_t_l_s_f_1a06b784dc5df9063ca8acd2c1b1e4d7fe" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>static size_t dsa::TLSF&lt; SLI &gt;::adjust_request_size</definition>
        <argsstring>(size_t size, size_t align)</argsstring>
        <name>adjust_request_size</name>
        <qualifiedname>dsa::TLSF::adjust_request_size</qualifiedname>
        <param>
          <type>size_t</type>
          <declname>size</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>align</declname>
        </param>
        <briefdescription>
<para>Adjusts the requested allocation size to be aligned to the specified alignment and ensures it is not smaller than the minimum block size. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>The requested allocation size. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>align</parametername>
</parameternamelist>
<parameterdescription>
<para>The required alignment. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The adjusted allocation size. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="338" column="26" bodyfile="src/tlsf.hpp" bodystart="338" bodyend="347"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1_t_l_s_f_1a7aaa27582e40b9eabb7d4c03c5facb04" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>static void dsa::TLSF&lt; SLI &gt;::mapping_insert</definition>
        <argsstring>(size_t size, int *fli, int *sli)</argsstring>
        <name>mapping_insert</name>
        <qualifiedname>dsa::TLSF::mapping_insert</qualifiedname>
        <param>
          <type>size_t</type>
          <declname>size</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>fli</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>sli</declname>
        </param>
        <briefdescription>
<para>Maps the given size to <ref refid="classdsa_1_1_t_l_s_f" kindref="compound">TLSF</ref> first-level (fli) and second-level (sli) indices. </para>
        </briefdescription>
        <detaileddescription>
<para>For sizes smaller than SMALL_BLOCK_SIZE, the first-level index is set to 0, and the second-level index is computed based on the size. For larger sizes, the indices are computed using the most significant bit (via fls) with additional bit manipulations.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>The size to be mapped. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fli</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to store the computed first-level index. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sli</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to store the computed second-level index. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="360" column="24" bodyfile="src/tlsf.hpp" bodystart="360" bodyend="377"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1_t_l_s_f_1aa795026851710838eac2340ab77c9a3f" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>static void dsa::TLSF&lt; SLI &gt;::mapping_search</definition>
        <argsstring>(size_t size, int *fli, int *sli)</argsstring>
        <name>mapping_search</name>
        <qualifiedname>dsa::TLSF::mapping_search</qualifiedname>
        <param>
          <type>size_t</type>
          <declname>size</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>fli</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>sli</declname>
        </param>
        <briefdescription>
<para>Rounds up the requested size and maps it to <ref refid="classdsa_1_1_t_l_s_f" kindref="compound">TLSF</ref> indices. </para>
        </briefdescription>
        <detaileddescription>
<para>If the requested size is at least SMALL_BLOCK_SIZE, a rounding value is computed and added to the size. Then, mapping_insert is called to determine the corresponding <ref refid="classdsa_1_1_t_l_s_f" kindref="compound">TLSF</ref> indices.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>The requested allocation size. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fli</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to store the computed first-level index. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sli</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to store the computed second-level index. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="389" column="24" bodyfile="src/tlsf.hpp" bodystart="389" bodyend="397"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1_t_l_s_f_1ad2d8098eda4e9b2e07ea2d6e86a89262" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="structdsa_1_1_t_l_s_f_1_1_block_header" kindref="compound">BlockHeader</ref> *</type>
        <definition>static BlockHeader * dsa::TLSF&lt; SLI &gt;::search_suitable_block</definition>
        <argsstring>(Control *control, int *fli, int *sli)</argsstring>
        <name>search_suitable_block</name>
        <qualifiedname>dsa::TLSF::search_suitable_block</qualifiedname>
        <param>
          <type><ref refid="structdsa_1_1_t_l_s_f_1_1_control" kindref="compound">Control</ref> *</type>
          <declname>control</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>fli</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>sli</declname>
        </param>
        <briefdescription>
<para>Searches for a suitable free block in the <ref refid="classdsa_1_1_t_l_s_f" kindref="compound">TLSF</ref> allocator. </para>
        </briefdescription>
        <detaileddescription>
<para>This function uses the provided first-level and second-level indices to locate a free block that is large enough to satisfy the allocation requirements. If no block is found in the current first-level list, the function searches in the next higher-level list.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>control</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the <ref refid="classdsa_1_1_t_l_s_f" kindref="compound">TLSF</ref> control structure. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fli</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the first-level index; updated during the search. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sli</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the second-level index; updated during the search. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Pointer to a free block that satisfies the criteria, or nullptr if none is found. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="415" column="31" bodyfile="src/tlsf.hpp" bodystart="415" bodyend="436"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1_t_l_s_f_1a57e28078474fdc0853060430d5454920" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>static void dsa::TLSF&lt; SLI &gt;::remove_free_block</definition>
        <argsstring>(Control *control, BlockHeader *block, int fl, int sl)</argsstring>
        <name>remove_free_block</name>
        <qualifiedname>dsa::TLSF::remove_free_block</qualifiedname>
        <param>
          <type><ref refid="structdsa_1_1_t_l_s_f_1_1_control" kindref="compound">Control</ref> *</type>
          <declname>control</declname>
        </param>
        <param>
          <type><ref refid="structdsa_1_1_t_l_s_f_1_1_block_header" kindref="compound">BlockHeader</ref> *</type>
          <declname>block</declname>
        </param>
        <param>
          <type>int</type>
          <declname>fl</declname>
        </param>
        <param>
          <type>int</type>
          <declname>sl</declname>
        </param>
        <briefdescription>
<para>Removes a block from the free list. </para>
        </briefdescription>
        <detaileddescription>
<para>Detaches the specified block from its free list by updating its previous and next pointers and adjusts the free list bitmaps corresponding to the first-level and second-level indices.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>control</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the <ref refid="classdsa_1_1_t_l_s_f" kindref="compound">TLSF</ref> control structure. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>block</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the block to be removed. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fl</parametername>
</parameternamelist>
<parameterdescription>
<para>The first-level index associated with the block. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sl</parametername>
</parameternamelist>
<parameterdescription>
<para>The second-level index associated with the block. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="449" column="24" bodyfile="src/tlsf.hpp" bodystart="449" bodyend="467"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1_t_l_s_f_1a07deb05a505f94dfbd6eb637a151008a" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>static void dsa::TLSF&lt; SLI &gt;::insert_free_block</definition>
        <argsstring>(Control *control, BlockHeader *block, int fl, int sl)</argsstring>
        <name>insert_free_block</name>
        <qualifiedname>dsa::TLSF::insert_free_block</qualifiedname>
        <param>
          <type><ref refid="structdsa_1_1_t_l_s_f_1_1_control" kindref="compound">Control</ref> *</type>
          <declname>control</declname>
        </param>
        <param>
          <type><ref refid="structdsa_1_1_t_l_s_f_1_1_block_header" kindref="compound">BlockHeader</ref> *</type>
          <declname>block</declname>
        </param>
        <param>
          <type>int</type>
          <declname>fl</declname>
        </param>
        <param>
          <type>int</type>
          <declname>sl</declname>
        </param>
        <briefdescription>
<para>Inserts a block into the free list. </para>
        </briefdescription>
        <detaileddescription>
<para>Adds the specified block into the free list at the given first-level and second-level indices, updating the free list pointers and associated bitmaps accordingly.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>control</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the <ref refid="classdsa_1_1_t_l_s_f" kindref="compound">TLSF</ref> control structure. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>block</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the block to be inserted. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fl</parametername>
</parameternamelist>
<parameterdescription>
<para>The first-level index where the block is to be inserted. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sl</parametername>
</parameternamelist>
<parameterdescription>
<para>The second-level index where the block is to be inserted. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="480" column="24" bodyfile="src/tlsf.hpp" bodystart="480" bodyend="494"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1_t_l_s_f_1a0618f620681909344d8bcef6844a02c8" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>static void dsa::TLSF&lt; SLI &gt;::remove</definition>
        <argsstring>(Control *control, BlockHeader *block)</argsstring>
        <name>remove</name>
        <qualifiedname>dsa::TLSF::remove</qualifiedname>
        <param>
          <type><ref refid="structdsa_1_1_t_l_s_f_1_1_control" kindref="compound">Control</ref> *</type>
          <declname>control</declname>
        </param>
        <param>
          <type><ref refid="structdsa_1_1_t_l_s_f_1_1_block_header" kindref="compound">BlockHeader</ref> *</type>
          <declname>block</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="497" column="24" bodyfile="src/tlsf.hpp" bodystart="497" bodyend="502"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1_t_l_s_f_1a0dc5ae2b42c39b8ebafbb0cd4d5ac5a7" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>static void dsa::TLSF&lt; SLI &gt;::insert</definition>
        <argsstring>(Control *control, BlockHeader *block)</argsstring>
        <name>insert</name>
        <qualifiedname>dsa::TLSF::insert</qualifiedname>
        <param>
          <type><ref refid="structdsa_1_1_t_l_s_f_1_1_control" kindref="compound">Control</ref> *</type>
          <declname>control</declname>
        </param>
        <param>
          <type><ref refid="structdsa_1_1_t_l_s_f_1_1_block_header" kindref="compound">BlockHeader</ref> *</type>
          <declname>block</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="505" column="24" bodyfile="src/tlsf.hpp" bodystart="505" bodyend="510"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1_t_l_s_f_1a271e026d5fb745b208a474b99c51c99f" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>static bool dsa::TLSF&lt; SLI &gt;::can_split</definition>
        <argsstring>(BlockHeader *block, size_t size)</argsstring>
        <name>can_split</name>
        <qualifiedname>dsa::TLSF::can_split</qualifiedname>
        <param>
          <type><ref refid="structdsa_1_1_t_l_s_f_1_1_block_header" kindref="compound">BlockHeader</ref> *</type>
          <declname>block</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>size</declname>
        </param>
        <briefdescription>
<para>Checks whether a block can be split into two blocks. </para>
        </briefdescription>
        <detaileddescription>
<para>This function verifies if the given block&apos;s size is large enough to be divided into a block of the desired size plus the overhead required for the block header.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>block</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the block header to check. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>The desired size for the first block after splitting. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>True if the block can be split; false otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="523" column="24" bodyfile="src/tlsf.hpp" bodystart="523" bodyend="526"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1_t_l_s_f_1a75ecbddac7f300f34d8c255d6de22202" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="structdsa_1_1_t_l_s_f_1_1_block_header" kindref="compound">BlockHeader</ref> *</type>
        <definition>static BlockHeader * dsa::TLSF&lt; SLI &gt;::split</definition>
        <argsstring>(BlockHeader *block, size_t size)</argsstring>
        <name>split</name>
        <qualifiedname>dsa::TLSF::split</qualifiedname>
        <param>
          <type><ref refid="structdsa_1_1_t_l_s_f_1_1_block_header" kindref="compound">BlockHeader</ref> *</type>
          <declname>block</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>size</declname>
        </param>
        <briefdescription>
<para>Splits a block into two parts. </para>
        </briefdescription>
        <detaileddescription>
<para>The function reduces the size of the original block to the requested size and creates a remaining block from the leftover space. It ensures that the remaining block is properly aligned and meets the minimum block size requirement.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>block</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the original block header. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>The size for the allocated portion of the block. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Pointer to the remaining block after the split. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="539" column="31" bodyfile="src/tlsf.hpp" bodystart="539" bodyend="550"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1_t_l_s_f_1a1d0e453b3030deeb7f4e5537a4bdcaa1" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="structdsa_1_1_t_l_s_f_1_1_block_header" kindref="compound">BlockHeader</ref> *</type>
        <definition>static BlockHeader * dsa::TLSF&lt; SLI &gt;::absorb</definition>
        <argsstring>(BlockHeader *prev, BlockHeader *block)</argsstring>
        <name>absorb</name>
        <qualifiedname>dsa::TLSF::absorb</qualifiedname>
        <param>
          <type><ref refid="structdsa_1_1_t_l_s_f_1_1_block_header" kindref="compound">BlockHeader</ref> *</type>
          <declname>prev</declname>
        </param>
        <param>
          <type><ref refid="structdsa_1_1_t_l_s_f_1_1_block_header" kindref="compound">BlockHeader</ref> *</type>
          <declname>block</declname>
        </param>
        <briefdescription>
<para>Absorbs the second block into the first. </para>
        </briefdescription>
        <detaileddescription>
<para>Merges a block with its successor by adding the size of the second block (plus header overhead) to the first block and relinking the next block.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>prev</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the preceding block which will absorb the next block. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>block</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the block to be absorbed. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Pointer to the updated block after absorption. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="562" column="31" bodyfile="src/tlsf.hpp" bodystart="562" bodyend="568"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1_t_l_s_f_1af2641f51b9b064d86a22c330d5c1bd84" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="structdsa_1_1_t_l_s_f_1_1_block_header" kindref="compound">BlockHeader</ref> *</type>
        <definition>static BlockHeader * dsa::TLSF&lt; SLI &gt;::merge_prev</definition>
        <argsstring>(Control *control, BlockHeader *block)</argsstring>
        <name>merge_prev</name>
        <qualifiedname>dsa::TLSF::merge_prev</qualifiedname>
        <param>
          <type><ref refid="structdsa_1_1_t_l_s_f_1_1_control" kindref="compound">Control</ref> *</type>
          <declname>control</declname>
        </param>
        <param>
          <type><ref refid="structdsa_1_1_t_l_s_f_1_1_block_header" kindref="compound">BlockHeader</ref> *</type>
          <declname>block</declname>
        </param>
        <briefdescription>
<para>Merges the current block with its previous free neighbor. </para>
        </briefdescription>
        <detaileddescription>
<para>If the previous physical block is free, it is removed from the free list and merged with the current block.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>control</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the <ref refid="classdsa_1_1_t_l_s_f" kindref="compound">TLSF</ref> control structure. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>block</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the current block header. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Pointer to the merged block. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="579" column="31" bodyfile="src/tlsf.hpp" bodystart="579" bodyend="590"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1_t_l_s_f_1a7b5ac458179b4ccc499b03d2cb10c10d" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="structdsa_1_1_t_l_s_f_1_1_block_header" kindref="compound">BlockHeader</ref> *</type>
        <definition>static BlockHeader * dsa::TLSF&lt; SLI &gt;::merge_next</definition>
        <argsstring>(Control *control, BlockHeader *block)</argsstring>
        <name>merge_next</name>
        <qualifiedname>dsa::TLSF::merge_next</qualifiedname>
        <param>
          <type><ref refid="structdsa_1_1_t_l_s_f_1_1_control" kindref="compound">Control</ref> *</type>
          <declname>control</declname>
        </param>
        <param>
          <type><ref refid="structdsa_1_1_t_l_s_f_1_1_block_header" kindref="compound">BlockHeader</ref> *</type>
          <declname>block</declname>
        </param>
        <briefdescription>
<para>Merges the current block with its next free neighbor. </para>
        </briefdescription>
        <detaileddescription>
<para>If the next physical block is free, it is removed from the free list and merged with the current block.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>control</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the <ref refid="classdsa_1_1_t_l_s_f" kindref="compound">TLSF</ref> control structure. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>block</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the current block header. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Pointer to the merged block. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="601" column="31" bodyfile="src/tlsf.hpp" bodystart="601" bodyend="612"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1_t_l_s_f_1a52605b6620223a08ca21559d318c91d0" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>static void dsa::TLSF&lt; SLI &gt;::trim_free</definition>
        <argsstring>(Control *control, BlockHeader *block, size_t size)</argsstring>
        <name>trim_free</name>
        <qualifiedname>dsa::TLSF::trim_free</qualifiedname>
        <param>
          <type><ref refid="structdsa_1_1_t_l_s_f_1_1_control" kindref="compound">Control</ref> *</type>
          <declname>control</declname>
        </param>
        <param>
          <type><ref refid="structdsa_1_1_t_l_s_f_1_1_block_header" kindref="compound">BlockHeader</ref> *</type>
          <declname>block</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>size</declname>
        </param>
        <briefdescription>
<para>Trims a free block to a specified size. </para>
        </briefdescription>
        <detaileddescription>
<para>If the free block is large enough to be split, this function splits the block, adjusts the next block pointer, marks the remaining block as free, and inserts it into the free list.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>control</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the <ref refid="classdsa_1_1_t_l_s_f" kindref="compound">TLSF</ref> control structure. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>block</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the free block to trim. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>The desired allocation size. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="624" column="24" bodyfile="src/tlsf.hpp" bodystart="624" bodyend="634"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1_t_l_s_f_1a7d4b158b6ac8cdff4023397b9ab3ced2" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>static void dsa::TLSF&lt; SLI &gt;::trim_used</definition>
        <argsstring>(Control *control, BlockHeader *block, size_t size)</argsstring>
        <name>trim_used</name>
        <qualifiedname>dsa::TLSF::trim_used</qualifiedname>
        <param>
          <type><ref refid="structdsa_1_1_t_l_s_f_1_1_control" kindref="compound">Control</ref> *</type>
          <declname>control</declname>
        </param>
        <param>
          <type><ref refid="structdsa_1_1_t_l_s_f_1_1_block_header" kindref="compound">BlockHeader</ref> *</type>
          <declname>block</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>size</declname>
        </param>
        <briefdescription>
<para>Trims a used block to the specified allocation size. </para>
        </briefdescription>
        <detaileddescription>
<para>If the used block can be split, this function divides the block, marks the remaining part as used, merges it with the next free block if possible, and reinserts it into the free list.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>control</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the <ref refid="classdsa_1_1_t_l_s_f" kindref="compound">TLSF</ref> control structure. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>block</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the used block to trim. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>The requested allocation size. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="646" column="24" bodyfile="src/tlsf.hpp" bodystart="646" bodyend="656"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1_t_l_s_f_1a3caa818d20ad9f4c114c28b79b2d6904" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="structdsa_1_1_t_l_s_f_1_1_block_header" kindref="compound">BlockHeader</ref> *</type>
        <definition>static BlockHeader * dsa::TLSF&lt; SLI &gt;::trim_free_leading</definition>
        <argsstring>(Control *control, BlockHeader *block, size_t size)</argsstring>
        <name>trim_free_leading</name>
        <qualifiedname>dsa::TLSF::trim_free_leading</qualifiedname>
        <param>
          <type><ref refid="structdsa_1_1_t_l_s_f_1_1_control" kindref="compound">Control</ref> *</type>
          <declname>control</declname>
        </param>
        <param>
          <type><ref refid="structdsa_1_1_t_l_s_f_1_1_block_header" kindref="compound">BlockHeader</ref> *</type>
          <declname>block</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>size</declname>
        </param>
        <briefdescription>
<para>Trims the leading portion of a free block. </para>
        </briefdescription>
        <detaileddescription>
<para>Splits off a leading segment from a free block, adjusts pointers accordingly, and inserts the remainder back into the free list.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>control</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the <ref refid="classdsa_1_1_t_l_s_f" kindref="compound">TLSF</ref> control structure. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>block</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the original free block. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>The desired size for the leading segment. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Pointer to the remaining block after trimming. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="669" column="31" bodyfile="src/tlsf.hpp" bodystart="669" bodyend="680"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1_t_l_s_f_1afacb1adf4c48b2d06cafaa71b9f884d9" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="structdsa_1_1_t_l_s_f_1_1_block_header" kindref="compound">BlockHeader</ref> *</type>
        <definition>static BlockHeader * dsa::TLSF&lt; SLI &gt;::locate_free</definition>
        <argsstring>(Control *control, size_t size)</argsstring>
        <name>locate_free</name>
        <qualifiedname>dsa::TLSF::locate_free</qualifiedname>
        <param>
          <type><ref refid="structdsa_1_1_t_l_s_f_1_1_control" kindref="compound">Control</ref> *</type>
          <declname>control</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>size</declname>
        </param>
        <briefdescription>
<para>Locates a free block of sufficient size from the free list. </para>
        </briefdescription>
        <detaileddescription>
<para>Searches for a free block that meets or exceeds the requested size and removes it from the free list.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>control</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the <ref refid="classdsa_1_1_t_l_s_f" kindref="compound">TLSF</ref> control structure. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>The minimum required block size. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Pointer to a suitable free block, or null if none is found. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="691" column="31" bodyfile="src/tlsf.hpp" bodystart="691" bodyend="706"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1_t_l_s_f_1a9a2d2201883d300bf1568e53c09297c4" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void *</type>
        <definition>static void * dsa::TLSF&lt; SLI &gt;::prepare_used</definition>
        <argsstring>(Control *control, BlockHeader *block, size_t size)</argsstring>
        <name>prepare_used</name>
        <qualifiedname>dsa::TLSF::prepare_used</qualifiedname>
        <param>
          <type><ref refid="structdsa_1_1_t_l_s_f_1_1_control" kindref="compound">Control</ref> *</type>
          <declname>control</declname>
        </param>
        <param>
          <type><ref refid="structdsa_1_1_t_l_s_f_1_1_block_header" kindref="compound">BlockHeader</ref> *</type>
          <declname>block</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>size</declname>
        </param>
        <briefdescription>
<para>Prepares a free block for allocation by marking it as used. </para>
        </briefdescription>
        <detaileddescription>
<para>Trims the block to the requested size, marks it as used, and returns a pointer to the usable memory region. If the block is null, this function returns null.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>control</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the <ref refid="classdsa_1_1_t_l_s_f" kindref="compound">TLSF</ref> control structure. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>block</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the free block to prepare. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>The desired allocation size. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Pointer to the allocated memory, or null if block is null. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="719" column="24" bodyfile="src/tlsf.hpp" bodystart="719" bodyend="730"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1_t_l_s_f_1ab0d208e1982ce713b1ef6fd7a6cb2336" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>static void dsa::TLSF&lt; SLI &gt;::initialise_control</definition>
        <argsstring>(Control *control)</argsstring>
        <name>initialise_control</name>
        <qualifiedname>dsa::TLSF::initialise_control</qualifiedname>
        <param>
          <type><ref refid="structdsa_1_1_t_l_s_f_1_1_control" kindref="compound">Control</ref> *</type>
          <declname>control</declname>
        </param>
        <briefdescription>
<para>Initializes the <ref refid="classdsa_1_1_t_l_s_f" kindref="compound">TLSF</ref> allocator control structure. </para>
        </briefdescription>
        <detaileddescription>
<para>Sets up the initial state of the allocator, including the free list pointers and bitmaps.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>control</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the control structure to initialize. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="739" column="24" bodyfile="src/tlsf.hpp" bodystart="739" bodyend="755"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1_t_l_s_f_1af06d06e73cb9a3a3a4c48e2016ab5dc4" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>static void dsa::TLSF&lt; SLI &gt;::default_walker</definition>
        <argsstring>(void *ptr, size_t size, int used, void *user)</argsstring>
        <name>default_walker</name>
        <qualifiedname>dsa::TLSF::default_walker</qualifiedname>
        <param>
          <type>void *</type>
          <declname>ptr</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>size</declname>
        </param>
        <param>
          <type>int</type>
          <declname>used</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>user</declname>
        </param>
        <briefdescription>
<para>Default walker callback function. </para>
        </briefdescription>
        <detaileddescription>
<para>This function is used as a default callback for iterating over memory blocks.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ptr</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the memory block. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>The size of the memory block in bytes. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>used</parametername>
</parameternamelist>
<parameterdescription>
<para>Flag indicating if the block is used (non-zero) or free (zero). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>user</parametername>
</parameternamelist>
<parameterdescription>
<para>User-defined parameter for callback context. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="767" column="24" bodyfile="src/tlsf.hpp" bodystart="767" bodyend="772"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1_t_l_s_f_1aaed5056de4768b8781b5c29d0ce257c6" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>static int dsa::TLSF&lt; SLI &gt;::check</definition>
        <argsstring>(Control *control)</argsstring>
        <name>check</name>
        <qualifiedname>dsa::TLSF::check</qualifiedname>
        <param>
          <type><ref refid="structdsa_1_1_t_l_s_f_1_1_control" kindref="compound">Control</ref> *</type>
          <declname>control</declname>
        </param>
        <briefdescription>
<para>Checks the consistency of the free lists and bitmaps in the <ref refid="classdsa_1_1_t_l_s_f" kindref="compound">TLSF</ref> allocator. </para>
        </briefdescription>
        <detaileddescription>
<para>This function iterates over all cabinets and shelves in the control structure to verify that the free lists and associated bitmaps accurately reflect the state of the allocator.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>control</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="classdsa_1_1_t_l_s_f" kindref="compound">TLSF</ref> control structure. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>An integer status code (0 indicates success). </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="784" column="23" bodyfile="src/tlsf.hpp" bodystart="784" bodyend="833"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1_t_l_s_f_1ab1504ff0e4c8fc95be7a591016c1bcdb" prot="public" static="yes" constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>static constexpr size_t dsa::TLSF&lt; SLI &gt;::cabinets</definition>
        <argsstring>()</argsstring>
        <name>cabinets</name>
        <qualifiedname>dsa::TLSF::cabinets</qualifiedname>
        <briefdescription>
<para>Returns the number of first-level indices (cabinets) in the allocator. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="837" column="36" bodyfile="src/tlsf.hpp" bodystart="837" bodyend="837"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1_t_l_s_f_1ab40635b4daeb1e0327e1760e31511a80" prot="public" static="yes" constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>static constexpr size_t dsa::TLSF&lt; SLI &gt;::shelves</definition>
        <argsstring>()</argsstring>
        <name>shelves</name>
        <qualifiedname>dsa::TLSF::shelves</qualifiedname>
        <briefdescription>
<para>Returns the number of shelves per cabinet. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="840" column="36" bodyfile="src/tlsf.hpp" bodystart="840" bodyend="840"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1_t_l_s_f_1a94184fce9ea53ceedd787ceb6d328c74" prot="public" static="yes" constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>static constexpr size_t dsa::TLSF&lt; SLI &gt;::total_shelves</definition>
        <argsstring>()</argsstring>
        <name>total_shelves</name>
        <qualifiedname>dsa::TLSF::total_shelves</qualifiedname>
        <briefdescription>
<para>Returns the total number of shelves in the allocator. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="843" column="36" bodyfile="src/tlsf.hpp" bodystart="843" bodyend="843"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1_t_l_s_f_1a9618212c00b858005a7e7c4d3891d992" prot="public" static="yes" constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>static constexpr size_t dsa::TLSF&lt; SLI &gt;::size</definition>
        <argsstring>()</argsstring>
        <name>size</name>
        <qualifiedname>dsa::TLSF::size</qualifiedname>
        <briefdescription>
<para>Returns the size of the allocator&apos;s control structure. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="846" column="36" bodyfile="src/tlsf.hpp" bodystart="846" bodyend="846"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1_t_l_s_f_1aa368212269f0ea11be46c699c43cc548" prot="public" static="yes" constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>static constexpr size_t dsa::TLSF&lt; SLI &gt;::align_size</definition>
        <argsstring>()</argsstring>
        <name>align_size</name>
        <qualifiedname>dsa::TLSF::align_size</qualifiedname>
        <briefdescription>
<para>Returns the alignment size used by the allocator. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="849" column="36" bodyfile="src/tlsf.hpp" bodystart="849" bodyend="849"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1_t_l_s_f_1a89ba8da1eed88f7ce1540d3b8dbfb10b" prot="public" static="yes" constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>static constexpr size_t dsa::TLSF&lt; SLI &gt;::min_block_size</definition>
        <argsstring>()</argsstring>
        <name>min_block_size</name>
        <qualifiedname>dsa::TLSF::min_block_size</qualifiedname>
        <briefdescription>
<para>Returns the minimum allowable block size. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="852" column="36" bodyfile="src/tlsf.hpp" bodystart="852" bodyend="852"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1_t_l_s_f_1a8c4a779e143cd73fe56782c936795dd6" prot="public" static="yes" constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>static constexpr size_t dsa::TLSF&lt; SLI &gt;::max_block_size</definition>
        <argsstring>()</argsstring>
        <name>max_block_size</name>
        <qualifiedname>dsa::TLSF::max_block_size</qualifiedname>
        <briefdescription>
<para>Returns the maximum allowable block size. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="855" column="36" bodyfile="src/tlsf.hpp" bodystart="855" bodyend="855"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1_t_l_s_f_1a5d88bfb8ba87a80e7f69cf7e02a40244" prot="public" static="yes" constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>static constexpr size_t dsa::TLSF&lt; SLI &gt;::pool_overhead</definition>
        <argsstring>()</argsstring>
        <name>pool_overhead</name>
        <qualifiedname>dsa::TLSF::pool_overhead</qualifiedname>
        <briefdescription>
<para>Returns the overhead (in bytes) of the memory pool due to allocator internal bookkeeping. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="858" column="36" bodyfile="src/tlsf.hpp" bodystart="858" bodyend="858"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1_t_l_s_f_1a1e7328266ccc90058b455aea1ba93746" prot="public" static="yes" constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>static constexpr size_t dsa::TLSF&lt; SLI &gt;::alloc_overhead</definition>
        <argsstring>()</argsstring>
        <name>alloc_overhead</name>
        <qualifiedname>dsa::TLSF::alloc_overhead</qualifiedname>
        <briefdescription>
<para>Returns the overhead (in bytes) incurred during each allocation. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="861" column="36" bodyfile="src/tlsf.hpp" bodystart="861" bodyend="861"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1_t_l_s_f_1aee18af47433b4624c23364b9a0e6ad6d" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>static size_t dsa::TLSF&lt; SLI &gt;::block_size</definition>
        <argsstring>(void *ptr)</argsstring>
        <name>block_size</name>
        <qualifiedname>dsa::TLSF::block_size</qualifiedname>
        <param>
          <type>void *</type>
          <declname>ptr</declname>
        </param>
        <briefdescription>
<para>Returns the block size in bytes. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/tlsf.hpp" line="864" column="26" bodyfile="src/tlsf.hpp" bodystart="864" bodyend="873"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="src/tlsf.hpp" line="37" column="1" bodyfile="src/tlsf.hpp" bodystart="38" bodyend="874"/>
    <listofallmembers>
      <member refid="classdsa_1_1_t_l_s_f_1a1d0e453b3030deeb7f4e5537a4bdcaa1" prot="public" virt="non-virtual"><scope>dsa::TLSF</scope><name>absorb</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1a06b784dc5df9063ca8acd2c1b1e4d7fe" prot="public" virt="non-virtual"><scope>dsa::TLSF</scope><name>adjust_request_size</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1adbb8bb2285eca7f84e3529b4207215d1" prot="public" virt="non-virtual"><scope>dsa::TLSF</scope><name>align_down</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1a7c1da7e5d6c2006a19c5692c8813fdd1" prot="public" virt="non-virtual"><scope>dsa::TLSF</scope><name>align_ptr</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1a9e9ae52d67bb0faf1920c4c4b8376adc" prot="private" virt="non-virtual"><scope>dsa::TLSF</scope><name>ALIGN_SIZE</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1aa368212269f0ea11be46c699c43cc548" prot="public" virt="non-virtual"><scope>dsa::TLSF</scope><name>align_size</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1ab129613ed2f692569608a6e438c60d43" prot="private" virt="non-virtual"><scope>dsa::TLSF</scope><name>ALIGN_SIZE_LOG2</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1afa49f068970ffe8c065baf6b112c7c32" prot="public" virt="non-virtual"><scope>dsa::TLSF</scope><name>align_up</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1a1e7328266ccc90058b455aea1ba93746" prot="public" virt="non-virtual"><scope>dsa::TLSF</scope><name>alloc_overhead</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1a882d30dfb67c91f27dffe235be08421b" prot="private" virt="non-virtual"><scope>dsa::TLSF</scope><name>BLOCK_ALIGNMENT</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1a06de927aa2f1743e93856f9429881a03" prot="private" virt="non-virtual"><scope>dsa::TLSF</scope><name>block_header_overhead</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1aee18af47433b4624c23364b9a0e6ad6d" prot="public" virt="non-virtual"><scope>dsa::TLSF</scope><name>block_size</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1a53417c63ebdd45bcc2f4955856929444" prot="private" virt="non-virtual"><scope>dsa::TLSF</scope><name>block_size_max</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1ac4268e5c889fdf4b4781cf7d7e113464" prot="private" virt="non-virtual"><scope>dsa::TLSF</scope><name>block_size_min</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1ad0a3c2a58f2ac0c556c0e826b310f0e7" prot="private" virt="non-virtual"><scope>dsa::TLSF</scope><name>block_start_offset</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1ab1504ff0e4c8fc95be7a591016c1bcdb" prot="public" virt="non-virtual"><scope>dsa::TLSF</scope><name>cabinets</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1a271e026d5fb745b208a474b99c51c99f" prot="public" virt="non-virtual"><scope>dsa::TLSF</scope><name>can_split</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1aaed5056de4768b8781b5c29d0ce257c6" prot="public" virt="non-virtual"><scope>dsa::TLSF</scope><name>check</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1af06d06e73cb9a3a3a4c48e2016ab5dc4" prot="public" virt="non-virtual"><scope>dsa::TLSF</scope><name>default_walker</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1a4a3f725786424821919caeda3fc46c31" prot="private" virt="non-virtual"><scope>dsa::TLSF</scope><name>FL_INDEX_COUNT</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1aca7f46fa2019c78935d41e6b70576285" prot="private" virt="non-virtual"><scope>dsa::TLSF</scope><name>FL_INDEX_MAX</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1a8d8e01ead196273867c2b41e8927ca76" prot="private" virt="non-virtual"><scope>dsa::TLSF</scope><name>FL_INDEX_SHIFT</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1ae5fb2e3596c3c6e5b158f1ea583b57ad" prot="private" virt="non-virtual"><scope>dsa::TLSF</scope><name>flag_mask</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1a03169d6bc1a82126fb21b79025546622" prot="private" virt="non-virtual"><scope>dsa::TLSF</scope><name>free_bit</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1a0d8439adae15c9e8c26088702bcd3561" prot="public" virt="non-virtual"><scope>dsa::TLSF</scope><name>from_ptr</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1afd2921b2dac73664c9bdadff7abd6eb6" prot="public" virt="non-virtual"><scope>dsa::TLSF</scope><name>from_ptr_nc</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1aa3b06851f567dc4366f71faf793d278c" prot="public" virt="non-virtual"><scope>dsa::TLSF</scope><name>get_size</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1ab0d208e1982ce713b1ef6fd7a6cb2336" prot="public" virt="non-virtual"><scope>dsa::TLSF</scope><name>initialise_control</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1a0dc5ae2b42c39b8ebafbb0cd4d5ac5a7" prot="public" virt="non-virtual"><scope>dsa::TLSF</scope><name>insert</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1a07deb05a505f94dfbd6eb637a151008a" prot="public" virt="non-virtual"><scope>dsa::TLSF</scope><name>insert_free_block</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1a1c60aa4b3b12526b95628d9dba0c95be" prot="public" virt="non-virtual"><scope>dsa::TLSF</scope><name>is_free</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1adcbc2cc8ec2a8e348b2f7c12fb74c013" prot="public" virt="non-virtual"><scope>dsa::TLSF</scope><name>is_last</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1ac45a129e8e6228e0360fbc191652e9a6" prot="public" virt="non-virtual"><scope>dsa::TLSF</scope><name>is_prev_free</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1ab7f459a80a15779948a5b3436caa0fb2" prot="public" virt="non-virtual"><scope>dsa::TLSF</scope><name>link_next</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1afacb1adf4c48b2d06cafaa71b9f884d9" prot="public" virt="non-virtual"><scope>dsa::TLSF</scope><name>locate_free</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1a7aaa27582e40b9eabb7d4c03c5facb04" prot="public" virt="non-virtual"><scope>dsa::TLSF</scope><name>mapping_insert</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1aa795026851710838eac2340ab77c9a3f" prot="public" virt="non-virtual"><scope>dsa::TLSF</scope><name>mapping_search</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1a32b002299d6d511cfd4db6d6793d2a28" prot="public" virt="non-virtual"><scope>dsa::TLSF</scope><name>mark_as_free</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1a835dfcb50f18445e12725900519e3d12" prot="public" virt="non-virtual"><scope>dsa::TLSF</scope><name>mark_as_used</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1a8c4a779e143cd73fe56782c936795dd6" prot="public" virt="non-virtual"><scope>dsa::TLSF</scope><name>max_block_size</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1a7b5ac458179b4ccc499b03d2cb10c10d" prot="public" virt="non-virtual"><scope>dsa::TLSF</scope><name>merge_next</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1af2641f51b9b064d86a22c330d5c1bd84" prot="public" virt="non-virtual"><scope>dsa::TLSF</scope><name>merge_prev</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1a89ba8da1eed88f7ce1540d3b8dbfb10b" prot="public" virt="non-virtual"><scope>dsa::TLSF</scope><name>min_block_size</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1a95fb2325991390b7e21889d5f212e231" prot="public" virt="non-virtual"><scope>dsa::TLSF</scope><name>next</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1ad8b1895322339e22c5206069f2bb5300" prot="public" virt="non-virtual"><scope>dsa::TLSF</scope><name>next_const</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1aed92fd15dfab650b5f73f49b3ec02069" prot="public" virt="non-virtual"><scope>dsa::TLSF</scope><name>offset_to_block</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1abc81913bafee4d307d838896319a0ca1" prot="public" virt="non-virtual"><scope>dsa::TLSF</scope><name>offset_to_block_nc</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1a5d88bfb8ba87a80e7f69cf7e02a40244" prot="public" virt="non-virtual"><scope>dsa::TLSF</scope><name>pool_overhead</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1a9a2d2201883d300bf1568e53c09297c4" prot="public" virt="non-virtual"><scope>dsa::TLSF</scope><name>prepare_used</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1a916561111ba5eefbd3fb72dba5232bfc" prot="public" virt="non-virtual"><scope>dsa::TLSF</scope><name>prev</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1aa8384db13c8af386f1d045f57c4ab2a2" prot="private" virt="non-virtual"><scope>dsa::TLSF</scope><name>prev_free_bit</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1a0618f620681909344d8bcef6844a02c8" prot="public" virt="non-virtual"><scope>dsa::TLSF</scope><name>remove</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1a57e28078474fdc0853060430d5454920" prot="public" virt="non-virtual"><scope>dsa::TLSF</scope><name>remove_free_block</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1ad2d8098eda4e9b2e07ea2d6e86a89262" prot="public" virt="non-virtual"><scope>dsa::TLSF</scope><name>search_suitable_block</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1a5b817e5a0872cac294950e321bdf75ea" prot="public" virt="non-virtual"><scope>dsa::TLSF</scope><name>set_free</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1a8fa3eb30d8636dfb48c02ca7860ec733" prot="public" virt="non-virtual"><scope>dsa::TLSF</scope><name>set_prev_free</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1a4fd943d469f8d3be81ba66e109f8340f" prot="public" virt="non-virtual"><scope>dsa::TLSF</scope><name>set_prev_used</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1af56ea62a64a94a3620be635004a433b4" prot="public" virt="non-virtual"><scope>dsa::TLSF</scope><name>set_size</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1a72f2bfdf752ce60b3af7301ea029bffb" prot="public" virt="non-virtual"><scope>dsa::TLSF</scope><name>set_used</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1ab40635b4daeb1e0327e1760e31511a80" prot="public" virt="non-virtual"><scope>dsa::TLSF</scope><name>shelves</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1a9618212c00b858005a7e7c4d3891d992" prot="public" virt="non-virtual"><scope>dsa::TLSF</scope><name>size</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1a7f65c711cb6725696970774320d73895" prot="private" virt="non-virtual"><scope>dsa::TLSF</scope><name>SL_INDEX_LOG2</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1a7c40f02bc93658db4abe068103a35db5" prot="private" virt="non-virtual"><scope>dsa::TLSF</scope><name>SLI_COUNT</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1ac3ccc1c32d236a03bb2f0382b59557fd" prot="private" virt="non-virtual"><scope>dsa::TLSF</scope><name>SMALL_BLOCK_SIZE</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1a75ecbddac7f300f34d8c255d6de22202" prot="public" virt="non-virtual"><scope>dsa::TLSF</scope><name>split</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1ac2e907fdaba5c8fc4c9185a632d8efe6" prot="public" virt="non-virtual"><scope>dsa::TLSF</scope><name>tlsf_walker</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1a87a00ee083c05e19c43adac02c5d2c26" prot="public" virt="non-virtual"><scope>dsa::TLSF</scope><name>tlsfptr_t</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1ad3c09c50acbdbcd39ce1ef322b589392" prot="public" virt="non-virtual"><scope>dsa::TLSF</scope><name>to_ptr</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1a695ec978573cffb0ab2b9d9e28068e02" prot="public" virt="non-virtual"><scope>dsa::TLSF</scope><name>to_ptr_nc</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1a94184fce9ea53ceedd787ceb6d328c74" prot="public" virt="non-virtual"><scope>dsa::TLSF</scope><name>total_shelves</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1a52605b6620223a08ca21559d318c91d0" prot="public" virt="non-virtual"><scope>dsa::TLSF</scope><name>trim_free</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1a3caa818d20ad9f4c114c28b79b2d6904" prot="public" virt="non-virtual"><scope>dsa::TLSF</scope><name>trim_free_leading</name></member>
      <member refid="classdsa_1_1_t_l_s_f_1a7d4b158b6ac8cdff4023397b9ab3ced2" prot="public" virt="non-virtual"><scope>dsa::TLSF</scope><name>trim_used</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
