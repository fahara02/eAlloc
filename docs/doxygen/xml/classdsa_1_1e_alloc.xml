<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.13.2" xml:lang="en-US">
  <compounddef id="classdsa_1_1e_alloc" kind="class" language="C++" prot="public">
    <compoundname>dsa::eAlloc</compoundname>
    <includes refid="e_alloc_8hpp" local="no">eAlloc.hpp</includes>
    <innerclass refid="structdsa_1_1e_alloc_1_1_integrity_result" prot="public">dsa::eAlloc::IntegrityResult</innerclass>
    <innerclass refid="structdsa_1_1e_alloc_1_1_storage_report" prot="public">dsa::eAlloc::StorageReport</innerclass>
    <sectiondef kind="public-type">
      <memberdef kind="typedef" id="classdsa_1_1e_alloc_1ae788e9d3eb03abbd532ef5ce3477edab" prot="public" static="no">
        <type><ref refid="classdsa_1_1_t_l_s_f" kindref="compound">dsa::TLSF</ref>&lt; 5 &gt;</type>
        <definition>using dsa::eAlloc::tlsf =  dsa::TLSF&lt;5&gt;</definition>
        <argsstring></argsstring>
        <name>tlsf</name>
        <qualifiedname>dsa::eAlloc::tlsf</qualifiedname>
        <briefdescription>
<para><ref refid="classdsa_1_1_t_l_s_f" kindref="compound">TLSF</ref> allocator with 32 second-level lists. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/eAlloc.hpp" line="53" column="5" bodyfile="src/eAlloc.hpp" bodystart="53" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classdsa_1_1e_alloc_1acbf770d2d9ab8ceb8df2a935a82eea10" prot="public" static="no">
        <type>tlsf::Control</type>
        <definition>using dsa::eAlloc::Control =  tlsf::Control</definition>
        <argsstring></argsstring>
        <name>Control</name>
        <qualifiedname>dsa::eAlloc::Control</qualifiedname>
        <briefdescription>
<para><ref refid="classdsa_1_1_t_l_s_f" kindref="compound">TLSF</ref> control structure type. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/eAlloc.hpp" line="54" column="5" bodyfile="src/eAlloc.hpp" bodystart="54" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classdsa_1_1e_alloc_1a3dabd178fc159716de6dd7c041eb17b0" prot="public" static="no">
        <type>tlsf::BlockHeader</type>
        <definition>using dsa::eAlloc::BlockHeader =  tlsf::BlockHeader</definition>
        <argsstring></argsstring>
        <name>BlockHeader</name>
        <qualifiedname>dsa::eAlloc::BlockHeader</qualifiedname>
        <briefdescription>
<para><ref refid="classdsa_1_1_t_l_s_f" kindref="compound">TLSF</ref> block header type. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/eAlloc.hpp" line="55" column="5" bodyfile="src/eAlloc.hpp" bodystart="55" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classdsa_1_1e_alloc_1a50adb94983befce215dcff2aecfab2f4" prot="public" static="no">
        <type><ref refid="classdsa_1_1_t_l_s_f_1ac2e907fdaba5c8fc4c9185a632d8efe6" kindref="member">tlsf::tlsf_walker</ref></type>
        <definition>using dsa::eAlloc::Walker =  tlsf::tlsf_walker</definition>
        <argsstring></argsstring>
        <name>Walker</name>
        <qualifiedname>dsa::eAlloc::Walker</qualifiedname>
        <briefdescription>
<para>Function type for walking memory blocks. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/eAlloc.hpp" line="56" column="5" bodyfile="src/eAlloc.hpp" bodystart="56" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="public-static-attrib">
      <memberdef kind="variable" id="classdsa_1_1e_alloc_1a00bb3a88d7fd0f8148deb3a0786a9d64" prot="public" static="yes" constexpr="yes" mutable="no">
        <type>size_t</type>
        <definition>size_t dsa::eAlloc::MAX_POOL</definition>
        <argsstring></argsstring>
        <name>MAX_POOL</name>
        <qualifiedname>dsa::eAlloc::MAX_POOL</qualifiedname>
        <initializer>= 5</initializer>
        <briefdescription>
<para>Maximum number of memory pools allowed. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/eAlloc.hpp" line="35" column="29" bodyfile="src/eAlloc.hpp" bodystart="35" bodyend="-1"/>
        <referencedby refid="classdsa_1_1e_alloc_1a430864385c853363d2c44678d00e0f95" compoundref="e_alloc_8cpp" startline="23" endline="77">add_pool</referencedby>
      </memberdef>
    </sectiondef>
    <sectiondef kind="private-attrib">
      <memberdef kind="variable" id="classdsa_1_1e_alloc_1acede9859339f8409d85c7a14cd71f6f2" prot="private" static="no" mutable="no">
        <type><ref refid="classdsa_1_1e_alloc_1acbf770d2d9ab8ceb8df2a935a82eea10" kindref="member">Control</ref></type>
        <definition>Control dsa::eAlloc::control</definition>
        <argsstring></argsstring>
        <name>control</name>
        <qualifiedname>dsa::eAlloc::control</qualifiedname>
        <briefdescription>
<para><ref refid="classdsa_1_1_t_l_s_f" kindref="compound">TLSF</ref> control structure. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/eAlloc.hpp" line="231" column="13" bodyfile="src/eAlloc.hpp" bodystart="231" bodyend="-1"/>
        <referencedby refid="classdsa_1_1e_alloc_1a430864385c853363d2c44678d00e0f95" compoundref="e_alloc_8cpp" startline="23" endline="77">add_pool</referencedby>
        <referencedby refid="classdsa_1_1e_alloc_1ad1f088a6a6ac5997e224ad0062c70523" compoundref="e_alloc_8cpp" startline="121" endline="121">check</referencedby>
        <referencedby refid="classdsa_1_1e_alloc_1aca9cba9a8b6174888e0774a6e9e92a36" compoundref="e_alloc_8cpp" startline="12" endline="21">eAlloc</referencedby>
        <referencedby refid="classdsa_1_1e_alloc_1a6cf6ea0950ef6c2c4d496a92c4786282" compoundref="e_alloc_8cpp" startline="147" endline="163">free</referencedby>
        <referencedby refid="classdsa_1_1e_alloc_1a5faaeb302c059421ca82cfc7db8e9879" compoundref="e_alloc_8cpp" startline="139" endline="145">malloc</referencedby>
        <referencedby refid="classdsa_1_1e_alloc_1ad55296e9a38ece48f061fd23b8fb1738" compoundref="e_alloc_8cpp" startline="177" endline="229">memalign</referencedby>
        <referencedby refid="classdsa_1_1e_alloc_1a56c8d1f3e2368a15361968596b335eeb" compoundref="e_alloc_8cpp" startline="231" endline="273">realloc</referencedby>
        <referencedby refid="classdsa_1_1e_alloc_1a8d029b14252fb77d1c2d5311b483abda" compoundref="e_alloc_8cpp" startline="79" endline="110">remove_pool</referencedby>
        <referencedby refid="classdsa_1_1e_alloc_1aabc4d2a1849719c8c1a136262ef7f681" compoundref="e_alloc_8cpp" startline="293" endline="325">report</referencedby>
      </memberdef>
      <memberdef kind="variable" id="classdsa_1_1e_alloc_1a029fe4dad4712ad2f5137c5ec15c9449" prot="private" static="no" mutable="no">
        <type>void *</type>
        <definition>void* dsa::eAlloc::memory_pools[MAX_POOL]</definition>
        <argsstring>[MAX_POOL]</argsstring>
        <name>memory_pools</name>
        <qualifiedname>dsa::eAlloc::memory_pools</qualifiedname>
        <briefdescription>
<para>Array of memory pool pointers. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/eAlloc.hpp" line="232" column="10" bodyfile="src/eAlloc.hpp" bodystart="232" bodyend="-1"/>
        <referencedby refid="classdsa_1_1e_alloc_1a430864385c853363d2c44678d00e0f95" compoundref="e_alloc_8cpp" startline="23" endline="77">add_pool</referencedby>
        <referencedby refid="classdsa_1_1e_alloc_1a8d029b14252fb77d1c2d5311b483abda" compoundref="e_alloc_8cpp" startline="79" endline="110">remove_pool</referencedby>
      </memberdef>
      <memberdef kind="variable" id="classdsa_1_1e_alloc_1ab191339864ad951a9b4174ed766ad024" prot="private" static="no" mutable="no">
        <type>size_t</type>
        <definition>size_t dsa::eAlloc::pool_sizes[MAX_POOL]</definition>
        <argsstring>[MAX_POOL]</argsstring>
        <name>pool_sizes</name>
        <qualifiedname>dsa::eAlloc::pool_sizes</qualifiedname>
        <briefdescription>
<para>store all pool sizes </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/eAlloc.hpp" line="233" column="12" bodyfile="src/eAlloc.hpp" bodystart="233" bodyend="-1"/>
        <referencedby refid="classdsa_1_1e_alloc_1a430864385c853363d2c44678d00e0f95" compoundref="e_alloc_8cpp" startline="23" endline="77">add_pool</referencedby>
        <referencedby refid="classdsa_1_1e_alloc_1a8d029b14252fb77d1c2d5311b483abda" compoundref="e_alloc_8cpp" startline="79" endline="110">remove_pool</referencedby>
      </memberdef>
      <memberdef kind="variable" id="classdsa_1_1e_alloc_1a814a2f70aa21ae4ecdb1caf09a368cbe" prot="private" static="no" mutable="no">
        <type>size_t</type>
        <definition>size_t dsa::eAlloc::pool_count</definition>
        <argsstring></argsstring>
        <name>pool_count</name>
        <qualifiedname>dsa::eAlloc::pool_count</qualifiedname>
        <initializer>= 0</initializer>
        <briefdescription>
<para>Number of active pools. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/eAlloc.hpp" line="234" column="12" bodyfile="src/eAlloc.hpp" bodystart="234" bodyend="-1"/>
        <referencedby refid="classdsa_1_1e_alloc_1a430864385c853363d2c44678d00e0f95" compoundref="e_alloc_8cpp" startline="23" endline="77">add_pool</referencedby>
        <referencedby refid="classdsa_1_1e_alloc_1a8d029b14252fb77d1c2d5311b483abda" compoundref="e_alloc_8cpp" startline="79" endline="110">remove_pool</referencedby>
      </memberdef>
      <memberdef kind="variable" id="classdsa_1_1e_alloc_1a5db3dffebe3e135f6629a128177ffa9e" prot="private" static="no" mutable="no">
        <type>bool</type>
        <definition>bool dsa::eAlloc::initialised</definition>
        <argsstring></argsstring>
        <name>initialised</name>
        <qualifiedname>dsa::eAlloc::initialised</qualifiedname>
        <initializer>= false</initializer>
        <briefdescription>
<para>Flag indicating if the allocator is initialized. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/eAlloc.hpp" line="235" column="10" bodyfile="src/eAlloc.hpp" bodystart="235" bodyend="-1"/>
        <referencedby refid="classdsa_1_1e_alloc_1aca9cba9a8b6174888e0774a6e9e92a36" compoundref="e_alloc_8cpp" startline="12" endline="21">eAlloc</referencedby>
      </memberdef>
      <memberdef kind="variable" id="classdsa_1_1e_alloc_1a69c9c5fe21b83dd7f8ae293395d1f21a" prot="private" static="no" mutable="no">
        <type>elock::IELockable *</type>
        <definition>elock::IELockable* dsa::eAlloc::elock_</definition>
        <argsstring></argsstring>
        <name>elock_</name>
        <qualifiedname>dsa::eAlloc::elock_</qualifiedname>
        <initializer>= nullptr</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/eAlloc.hpp" line="236" column="23" bodyfile="src/eAlloc.hpp" bodystart="236" bodyend="-1"/>
        <referencedby refid="classdsa_1_1e_alloc_1a430864385c853363d2c44678d00e0f95" compoundref="e_alloc_8cpp" startline="23" endline="77">add_pool</referencedby>
        <referencedby refid="classdsa_1_1e_alloc_1a01a9d3be9b919029d0d5bda73f56757c" compoundref="e_alloc_8cpp" startline="275" endline="291">calloc</referencedby>
        <referencedby refid="classdsa_1_1e_alloc_1a6cf6ea0950ef6c2c4d496a92c4786282" compoundref="e_alloc_8cpp" startline="147" endline="163">free</referencedby>
        <referencedby refid="classdsa_1_1e_alloc_1a5faaeb302c059421ca82cfc7db8e9879" compoundref="e_alloc_8cpp" startline="139" endline="145">malloc</referencedby>
        <referencedby refid="classdsa_1_1e_alloc_1a56c8d1f3e2368a15361968596b335eeb" compoundref="e_alloc_8cpp" startline="231" endline="273">realloc</referencedby>
        <referencedby refid="classdsa_1_1e_alloc_1a8d029b14252fb77d1c2d5311b483abda" compoundref="e_alloc_8cpp" startline="79" endline="110">remove_pool</referencedby>
        <referencedby refid="classdsa_1_1e_alloc_1aabc4d2a1849719c8c1a136262ef7f681" compoundref="e_alloc_8cpp" startline="293" endline="325">report</referencedby>
        <referencedby refid="classdsa_1_1e_alloc_1a0763696d9c6e5c93459ae6eeea137830" compoundref="e_alloc_8hpp" startline="37" endline="37">setELock</referencedby>
        <referencedby refid="classdsa_1_1e_alloc_1a799fb29ed4b5e3d4ab9a69cef933576a" compoundref="e_alloc_8cpp" startline="165" endline="175">walk_pool</referencedby>
      </memberdef>
    </sectiondef>
    <sectiondef kind="public-func">
      <memberdef kind="function" id="classdsa_1_1e_alloc_1a0763696d9c6e5c93459ae6eeea137830" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void dsa::eAlloc::setELock</definition>
        <argsstring>(elock::IELockable *lock)</argsstring>
        <name>setELock</name>
        <qualifiedname>dsa::eAlloc::setELock</qualifiedname>
        <param>
          <type>elock::IELockable *</type>
          <declname>lock</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/eAlloc.hpp" line="37" column="10" bodyfile="src/eAlloc.hpp" bodystart="37" bodyend="37"/>
        <references refid="classdsa_1_1e_alloc_1a69c9c5fe21b83dd7f8ae293395d1f21a" compoundref="e_alloc_8hpp" startline="236">elock_</references>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1e_alloc_1aca9cba9a8b6174888e0774a6e9e92a36" prot="public" static="no" const="no" explicit="yes" inline="no" virt="non-virtual">
        <type></type>
        <definition>dsa::eAlloc::eAlloc</definition>
        <argsstring>(void *mem, size_t bytes)</argsstring>
        <name>eAlloc</name>
        <qualifiedname>dsa::eAlloc::eAlloc</qualifiedname>
        <param>
          <type>void *</type>
          <declname>mem</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>bytes</declname>
        </param>
        <briefdescription>
<para>Constructs an <ref refid="classdsa_1_1e_alloc" kindref="compound">eAlloc</ref> instance with an initial memory pool. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mem</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the initial memory block. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bytes</parametername>
</parameternamelist>
<parameterdescription>
<para>Size of the initial memory block in bytes. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/eAlloc.hpp" line="44" column="14" bodyfile="src/eAlloc.cpp" bodystart="12" bodyend="21"/>
        <references refid="classdsa_1_1e_alloc_1a430864385c853363d2c44678d00e0f95" compoundref="e_alloc_8cpp" startline="23" endline="77">add_pool</references>
        <references refid="classdsa_1_1e_alloc_1acede9859339f8409d85c7a14cd71f6f2" compoundref="e_alloc_8hpp" startline="231">control</references>
        <references refid="namespace_l_o_g_1a9a5ec8f75979677739eddc5e1e61c043abb1ca97ec761fc37101737ba0aa2e7c5" compoundref="_logger_8hpp" startline="22">LOG::ERROR</references>
        <references refid="classdsa_1_1_t_l_s_f_1ab0d208e1982ce713b1ef6fd7a6cb2336" compoundref="tlsf_8hpp" startline="456" endline="472">dsa::TLSF&lt; 5 &gt;::initialise_control</references>
        <references refid="classdsa_1_1e_alloc_1a5db3dffebe3e135f6629a128177ffa9e" compoundref="e_alloc_8hpp" startline="235">initialised</references>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1e_alloc_1a5faaeb302c059421ca82cfc7db8e9879" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void *</type>
        <definition>void * dsa::eAlloc::malloc</definition>
        <argsstring>(size_t size)</argsstring>
        <name>malloc</name>
        <qualifiedname>dsa::eAlloc::malloc</qualifiedname>
        <param>
          <type>size_t</type>
          <declname>size</declname>
        </param>
        <briefdescription>
<para>Allocates a block of memory of the specified size. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>The size of the memory block to allocate in bytes. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Pointer to the allocated memory, or nullptr if allocation fails. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/eAlloc.hpp" line="72" column="10" bodyfile="src/eAlloc.cpp" bodystart="139" bodyend="145"/>
        <references refid="classdsa_1_1_t_l_s_f_1a06b784dc5df9063ca8acd2c1b1e4d7fe" compoundref="tlsf_8hpp" startline="233" endline="242">dsa::TLSF&lt; 5 &gt;::adjust_request_size</references>
        <references refid="classdsa_1_1_t_l_s_f_1aa368212269f0ea11be46c699c43cc548" compoundref="tlsf_8hpp" startline="536" endline="536">dsa::TLSF&lt; 5 &gt;::align_size</references>
        <references refid="classdsa_1_1e_alloc_1acede9859339f8409d85c7a14cd71f6f2" compoundref="e_alloc_8hpp" startline="231">control</references>
        <references refid="classdsa_1_1e_alloc_1a69c9c5fe21b83dd7f8ae293395d1f21a" compoundref="e_alloc_8hpp" startline="236">elock_</references>
        <references refid="classdsa_1_1_t_l_s_f_1afacb1adf4c48b2d06cafaa71b9f884d9" compoundref="tlsf_8hpp" startline="428" endline="443">dsa::TLSF&lt; 5 &gt;::locate_free</references>
        <references refid="classdsa_1_1_t_l_s_f_1a9a2d2201883d300bf1568e53c09297c4" compoundref="tlsf_8hpp" startline="444" endline="455">dsa::TLSF&lt; 5 &gt;::prepare_used</references>
        <referencedby refid="classdsa_1_1e_alloc_1a3cbe14b74b41cd912af2c4c2b277196b" compoundref="e_alloc_8hpp" startline="140" endline="158">allocate</referencedby>
        <referencedby refid="classdsa_1_1e_alloc_1a1c4355fbb45c0c0876a97a1bb2515f68" compoundref="e_alloc_8hpp" startline="112" endline="130">allocate</referencedby>
        <referencedby refid="classdsa_1_1e_alloc_1a01a9d3be9b919029d0d5bda73f56757c" compoundref="e_alloc_8cpp" startline="275" endline="291">calloc</referencedby>
        <referencedby refid="classdsa_1_1e_alloc_1a56c8d1f3e2368a15361968596b335eeb" compoundref="e_alloc_8cpp" startline="231" endline="273">realloc</referencedby>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1e_alloc_1a6cf6ea0950ef6c2c4d496a92c4786282" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void dsa::eAlloc::free</definition>
        <argsstring>(void *ptr)</argsstring>
        <name>free</name>
        <qualifiedname>dsa::eAlloc::free</qualifiedname>
        <param>
          <type>void *</type>
          <declname>ptr</declname>
        </param>
        <briefdescription>
<para>Frees a previously allocated memory block. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ptr</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the memory block to free. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/eAlloc.hpp" line="78" column="10" bodyfile="src/eAlloc.cpp" bodystart="147" bodyend="163"/>
        <references refid="classdsa_1_1e_alloc_1acede9859339f8409d85c7a14cd71f6f2" compoundref="e_alloc_8hpp" startline="231">control</references>
        <references refid="classdsa_1_1e_alloc_1a69c9c5fe21b83dd7f8ae293395d1f21a" compoundref="e_alloc_8hpp" startline="236">elock_</references>
        <references refid="namespace_l_o_g_1a9a5ec8f75979677739eddc5e1e61c043abb1ca97ec761fc37101737ba0aa2e7c5" compoundref="_logger_8hpp" startline="22">LOG::ERROR</references>
        <references refid="classdsa_1_1_t_l_s_f_1afd2921b2dac73664c9bdadff7abd6eb6" compoundref="tlsf_8hpp" startline="151" endline="155">dsa::TLSF&lt; 5 &gt;::from_ptr_nc</references>
        <references refid="classdsa_1_1_t_l_s_f_1a0dc5ae2b42c39b8ebafbb0cd4d5ac5a7" compoundref="tlsf_8hpp" startline="341" endline="346">dsa::TLSF&lt; 5 &gt;::insert</references>
        <references refid="classdsa_1_1_t_l_s_f_1a1c60aa4b3b12526b95628d9dba0c95be" compoundref="tlsf_8hpp" startline="108" endline="111">dsa::TLSF&lt; 5 &gt;::is_free</references>
        <references refid="classdsa_1_1_t_l_s_f_1a32b002299d6d511cfd4db6d6793d2a28" compoundref="tlsf_8hpp" startline="197" endline="203">dsa::TLSF&lt; 5 &gt;::mark_as_free</references>
        <references refid="classdsa_1_1_t_l_s_f_1a7b5ac458179b4ccc499b03d2cb10c10d" compoundref="tlsf_8hpp" startline="382" endline="393">dsa::TLSF&lt; 5 &gt;::merge_next</references>
        <references refid="classdsa_1_1_t_l_s_f_1af2641f51b9b064d86a22c330d5c1bd84" compoundref="tlsf_8hpp" startline="370" endline="381">dsa::TLSF&lt; 5 &gt;::merge_prev</references>
        <referencedby refid="classdsa_1_1e_alloc_1a3cbe14b74b41cd912af2c4c2b277196b" compoundref="e_alloc_8hpp" startline="140" endline="158">allocate</referencedby>
        <referencedby refid="classdsa_1_1e_alloc_1a1c4355fbb45c0c0876a97a1bb2515f68" compoundref="e_alloc_8hpp" startline="112" endline="130">allocate</referencedby>
        <referencedby refid="classdsa_1_1e_alloc_1a142ecbc514fb8d9618fee741dece6efc" compoundref="e_alloc_8hpp" startline="166" endline="171">deallocate</referencedby>
        <referencedby refid="classdsa_1_1e_alloc_1a56c8d1f3e2368a15361968596b335eeb" compoundref="e_alloc_8cpp" startline="231" endline="273">realloc</referencedby>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1e_alloc_1ad55296e9a38ece48f061fd23b8fb1738" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void *</type>
        <definition>void * dsa::eAlloc::memalign</definition>
        <argsstring>(size_t align, size_t size)</argsstring>
        <name>memalign</name>
        <qualifiedname>dsa::eAlloc::memalign</qualifiedname>
        <param>
          <type>size_t</type>
          <declname>align</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>size</declname>
        </param>
        <briefdescription>
<para>Allocates a memory block with specified alignment and size. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>align</parametername>
</parameternamelist>
<parameterdescription>
<para>The alignment requirement in bytes (must be a power of 2). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>The size of the memory block to allocate in bytes. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Pointer to the allocated memory, or nullptr if allocation fails. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/eAlloc.hpp" line="86" column="10" bodyfile="src/eAlloc.cpp" bodystart="177" bodyend="229"/>
        <references refid="classdsa_1_1_t_l_s_f_1a06b784dc5df9063ca8acd2c1b1e4d7fe" compoundref="tlsf_8hpp" startline="233" endline="242">dsa::TLSF&lt; 5 &gt;::adjust_request_size</references>
        <references refid="classdsa_1_1_t_l_s_f_1a7c1da7e5d6c2006a19c5692c8813fdd1" compoundref="tlsf_8hpp" startline="223" endline="228">dsa::TLSF&lt; 5 &gt;::align_ptr</references>
        <references refid="classdsa_1_1_t_l_s_f_1aa368212269f0ea11be46c699c43cc548" compoundref="tlsf_8hpp" startline="536" endline="536">dsa::TLSF&lt; 5 &gt;::align_size</references>
        <references refid="classdsa_1_1_t_l_s_f_1a1e7328266ccc90058b455aea1ba93746" compoundref="tlsf_8hpp" startline="540" endline="540">dsa::TLSF&lt; 5 &gt;::alloc_overhead</references>
        <references refid="classdsa_1_1e_alloc_1acede9859339f8409d85c7a14cd71f6f2" compoundref="e_alloc_8hpp" startline="231">control</references>
        <references refid="tlsf_8hpp_1a8dc2e3a9039658cafb6f76ce960c5512" compoundref="tlsf_8hpp" startline="23">dsa_assert</references>
        <references refid="namespace_l_o_g_1a9a5ec8f75979677739eddc5e1e61c043abb1ca97ec761fc37101737ba0aa2e7c5" compoundref="_logger_8hpp" startline="22">LOG::ERROR</references>
        <references refid="classdsa_1_1_t_l_s_f_1afacb1adf4c48b2d06cafaa71b9f884d9" compoundref="tlsf_8hpp" startline="428" endline="443">dsa::TLSF&lt; 5 &gt;::locate_free</references>
        <references refid="classdsa_1_1_t_l_s_f_1a89ba8da1eed88f7ce1540d3b8dbfb10b" compoundref="tlsf_8hpp" startline="537" endline="537">dsa::TLSF&lt; 5 &gt;::min_block_size</references>
        <references refid="classdsa_1_1_t_l_s_f_1a9a2d2201883d300bf1568e53c09297c4" compoundref="tlsf_8hpp" startline="444" endline="455">dsa::TLSF&lt; 5 &gt;::prepare_used</references>
        <references refid="classdsa_1_1_t_l_s_f_1a695ec978573cffb0ab2b9d9e28068e02" compoundref="tlsf_8hpp" startline="141" endline="145">dsa::TLSF&lt; 5 &gt;::to_ptr_nc</references>
        <references refid="classdsa_1_1_t_l_s_f_1a3caa818d20ad9f4c114c28b79b2d6904" compoundref="tlsf_8hpp" startline="416" endline="427">dsa::TLSF&lt; 5 &gt;::trim_free_leading</references>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1e_alloc_1a56c8d1f3e2368a15361968596b335eeb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void *</type>
        <definition>void * dsa::eAlloc::realloc</definition>
        <argsstring>(void *ptr, size_t size)</argsstring>
        <name>realloc</name>
        <qualifiedname>dsa::eAlloc::realloc</qualifiedname>
        <param>
          <type>void *</type>
          <declname>ptr</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>size</declname>
        </param>
        <briefdescription>
<para>Reallocates a memory block to a new size. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ptr</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the memory block to reallocate. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>The new size of the memory block in bytes. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Pointer to the reallocated memory, or nullptr if reallocation fails. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/eAlloc.hpp" line="95" column="10" bodyfile="src/eAlloc.cpp" bodystart="231" bodyend="273"/>
        <references refid="classdsa_1_1_t_l_s_f_1a06b784dc5df9063ca8acd2c1b1e4d7fe" compoundref="tlsf_8hpp" startline="233" endline="242">dsa::TLSF&lt; 5 &gt;::adjust_request_size</references>
        <references refid="classdsa_1_1_t_l_s_f_1aa368212269f0ea11be46c699c43cc548" compoundref="tlsf_8hpp" startline="536" endline="536">dsa::TLSF&lt; 5 &gt;::align_size</references>
        <references refid="classdsa_1_1_t_l_s_f_1a1e7328266ccc90058b455aea1ba93746" compoundref="tlsf_8hpp" startline="540" endline="540">dsa::TLSF&lt; 5 &gt;::alloc_overhead</references>
        <references refid="classdsa_1_1e_alloc_1acede9859339f8409d85c7a14cd71f6f2" compoundref="e_alloc_8hpp" startline="231">control</references>
        <references refid="tlsf_8hpp_1a8dc2e3a9039658cafb6f76ce960c5512" compoundref="tlsf_8hpp" startline="23">dsa_assert</references>
        <references refid="tlsf_8hpp_1a70745a619451430b9686efcb4982df49" compoundref="tlsf_8hpp" startline="11">dsa_min</references>
        <references refid="classdsa_1_1e_alloc_1a69c9c5fe21b83dd7f8ae293395d1f21a" compoundref="e_alloc_8hpp" startline="236">elock_</references>
        <references refid="classdsa_1_1e_alloc_1a6cf6ea0950ef6c2c4d496a92c4786282" compoundref="e_alloc_8cpp" startline="147" endline="163">free</references>
        <references refid="classdsa_1_1_t_l_s_f_1afd2921b2dac73664c9bdadff7abd6eb6" compoundref="tlsf_8hpp" startline="151" endline="155">dsa::TLSF&lt; 5 &gt;::from_ptr_nc</references>
        <references refid="classdsa_1_1_t_l_s_f_1aa3b06851f567dc4366f71faf793d278c" compoundref="tlsf_8hpp" startline="98" endline="101">dsa::TLSF&lt; 5 &gt;::get_size</references>
        <references refid="classdsa_1_1_t_l_s_f_1a1c60aa4b3b12526b95628d9dba0c95be" compoundref="tlsf_8hpp" startline="108" endline="111">dsa::TLSF&lt; 5 &gt;::is_free</references>
        <references refid="classdsa_1_1e_alloc_1a5faaeb302c059421ca82cfc7db8e9879" compoundref="e_alloc_8cpp" startline="139" endline="145">malloc</references>
        <references refid="classdsa_1_1_t_l_s_f_1a835dfcb50f18445e12725900519e3d12" compoundref="tlsf_8hpp" startline="205" endline="210">dsa::TLSF&lt; 5 &gt;::mark_as_used</references>
        <references refid="classdsa_1_1_t_l_s_f_1a7b5ac458179b4ccc499b03d2cb10c10d" compoundref="tlsf_8hpp" startline="382" endline="393">dsa::TLSF&lt; 5 &gt;::merge_next</references>
        <references refid="classdsa_1_1_t_l_s_f_1a95fb2325991390b7e21889d5f212e231" compoundref="tlsf_8hpp" startline="175" endline="181">dsa::TLSF&lt; 5 &gt;::next</references>
        <references refid="classdsa_1_1_t_l_s_f_1a7d4b158b6ac8cdff4023397b9ab3ced2" compoundref="tlsf_8hpp" startline="405" endline="415">dsa::TLSF&lt; 5 &gt;::trim_used</references>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1e_alloc_1a01a9d3be9b919029d0d5bda73f56757c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void *</type>
        <definition>void * dsa::eAlloc::calloc</definition>
        <argsstring>(size_t num, size_t size)</argsstring>
        <name>calloc</name>
        <qualifiedname>dsa::eAlloc::calloc</qualifiedname>
        <param>
          <type>size_t</type>
          <declname>num</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>size</declname>
        </param>
        <briefdescription>
<para>Allocates memory for an array and initializes it to zero. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>num</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of elements in the array. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>Size of each element in bytes. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Pointer to the allocated memory, or nullptr if allocation fails. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/eAlloc.hpp" line="103" column="10" bodyfile="src/eAlloc.cpp" bodystart="275" bodyend="291"/>
        <references refid="classdsa_1_1e_alloc_1a69c9c5fe21b83dd7f8ae293395d1f21a" compoundref="e_alloc_8hpp" startline="236">elock_</references>
        <references refid="namespace_l_o_g_1a9a5ec8f75979677739eddc5e1e61c043abb1ca97ec761fc37101737ba0aa2e7c5" compoundref="_logger_8hpp" startline="22">LOG::ERROR</references>
        <references refid="classdsa_1_1e_alloc_1a5faaeb302c059421ca82cfc7db8e9879" compoundref="e_alloc_8cpp" startline="139" endline="145">malloc</references>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1e_alloc_1a1c4355fbb45c0c0876a97a1bb2515f68" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>T *</type>
        <definition>T * dsa::eAlloc::allocate</definition>
        <argsstring>(const T &amp;obj)</argsstring>
        <name>allocate</name>
        <qualifiedname>dsa::eAlloc::allocate</qualifiedname>
        <param>
          <type>const T &amp;</type>
          <declname>obj</declname>
        </param>
        <briefdescription>
<para>Allocates memory for an object and constructs it by copying. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the object to allocate. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>obj</parametername>
</parameternamelist>
<parameterdescription>
<para>The object to copy-construct. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Pointer to the constructed object, or nullptr if allocation fails. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/eAlloc.hpp" line="112" column="7" bodyfile="src/eAlloc.hpp" bodystart="112" bodyend="130"/>
        <references refid="namespace_l_o_g_1a9a5ec8f75979677739eddc5e1e61c043abb1ca97ec761fc37101737ba0aa2e7c5" compoundref="_logger_8hpp" startline="22">LOG::ERROR</references>
        <references refid="classdsa_1_1e_alloc_1a6cf6ea0950ef6c2c4d496a92c4786282" compoundref="e_alloc_8cpp" startline="147" endline="163">free</references>
        <references refid="classdsa_1_1e_alloc_1a5faaeb302c059421ca82cfc7db8e9879" compoundref="e_alloc_8cpp" startline="139" endline="145">malloc</references>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1e_alloc_1a3cbe14b74b41cd912af2c4c2b277196b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type>T *</type>
        <definition>T * dsa::eAlloc::allocate</definition>
        <argsstring>(Args &amp;&amp;... args)</argsstring>
        <name>allocate</name>
        <qualifiedname>dsa::eAlloc::allocate</qualifiedname>
        <param>
          <type>Args &amp;&amp;...</type>
          <declname>args</declname>
        </param>
        <briefdescription>
<para>Allocates memory for an object and constructs it with arguments. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the object to allocate. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Args</parametername>
</parameternamelist>
<parameterdescription>
<para>Types of the constructor arguments. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>args</parametername>
</parameternamelist>
<parameterdescription>
<para>Arguments to pass to the object&apos;s constructor. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Pointer to the constructed object, or nullptr if allocation fails. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/eAlloc.hpp" line="140" column="7" bodyfile="src/eAlloc.hpp" bodystart="140" bodyend="158"/>
        <references refid="namespace_l_o_g_1a9a5ec8f75979677739eddc5e1e61c043abb1ca97ec761fc37101737ba0aa2e7c5" compoundref="_logger_8hpp" startline="22">LOG::ERROR</references>
        <references refid="classdsa_1_1e_alloc_1a6cf6ea0950ef6c2c4d496a92c4786282" compoundref="e_alloc_8cpp" startline="147" endline="163">free</references>
        <references refid="classdsa_1_1e_alloc_1a5faaeb302c059421ca82cfc7db8e9879" compoundref="e_alloc_8cpp" startline="139" endline="145">malloc</references>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1e_alloc_1a142ecbc514fb8d9618fee741dece6efc" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void dsa::eAlloc::deallocate</definition>
        <argsstring>(T *obj)</argsstring>
        <name>deallocate</name>
        <qualifiedname>dsa::eAlloc::deallocate</qualifiedname>
        <param>
          <type>T *</type>
          <declname>obj</declname>
        </param>
        <briefdescription>
<para>Deallocates an object and destroys it. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the object to deallocate. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>obj</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the object to deallocate. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/eAlloc.hpp" line="166" column="10" bodyfile="src/eAlloc.hpp" bodystart="166" bodyend="171"/>
        <references refid="classdsa_1_1e_alloc_1a6cf6ea0950ef6c2c4d496a92c4786282" compoundref="e_alloc_8cpp" startline="147" endline="163">free</references>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1e_alloc_1a430864385c853363d2c44678d00e0f95" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void *</type>
        <definition>void * dsa::eAlloc::add_pool</definition>
        <argsstring>(void *mem, size_t bytes)</argsstring>
        <name>add_pool</name>
        <qualifiedname>dsa::eAlloc::add_pool</qualifiedname>
        <param>
          <type>void *</type>
          <declname>mem</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>bytes</declname>
        </param>
        <briefdescription>
<para>Adds a new memory pool to the allocator. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mem</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the memory block to add as a pool. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bytes</parametername>
</parameternamelist>
<parameterdescription>
<para>Size of the memory block in bytes. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Pointer to the added pool, or nullptr if addition fails. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/eAlloc.hpp" line="179" column="10" bodyfile="src/eAlloc.cpp" bodystart="23" bodyend="77"/>
        <references refid="classdsa_1_1_t_l_s_f_1adbb8bb2285eca7f84e3529b4207215d1" compoundref="tlsf_8hpp" startline="217" endline="221">dsa::TLSF&lt; 5 &gt;::align_down</references>
        <references refid="classdsa_1_1_t_l_s_f_1aa368212269f0ea11be46c699c43cc548" compoundref="tlsf_8hpp" startline="536" endline="536">dsa::TLSF&lt; 5 &gt;::align_size</references>
        <references refid="classdsa_1_1_t_l_s_f_1a1e7328266ccc90058b455aea1ba93746" compoundref="tlsf_8hpp" startline="540" endline="540">dsa::TLSF&lt; 5 &gt;::alloc_overhead</references>
        <references refid="classdsa_1_1e_alloc_1acede9859339f8409d85c7a14cd71f6f2" compoundref="e_alloc_8hpp" startline="231">control</references>
        <references refid="classdsa_1_1e_alloc_1a69c9c5fe21b83dd7f8ae293395d1f21a" compoundref="e_alloc_8hpp" startline="236">elock_</references>
        <references refid="namespace_l_o_g_1a9a5ec8f75979677739eddc5e1e61c043abb1ca97ec761fc37101737ba0aa2e7c5" compoundref="_logger_8hpp" startline="22">LOG::ERROR</references>
        <references refid="classdsa_1_1_t_l_s_f_1a0dc5ae2b42c39b8ebafbb0cd4d5ac5a7" compoundref="tlsf_8hpp" startline="341" endline="346">dsa::TLSF&lt; 5 &gt;::insert</references>
        <references refid="classdsa_1_1_t_l_s_f_1ab7f459a80a15779948a5b3436caa0fb2" compoundref="tlsf_8hpp" startline="191" endline="196">dsa::TLSF&lt; 5 &gt;::link_next</references>
        <references refid="classdsa_1_1_t_l_s_f_1a8c4a779e143cd73fe56782c936795dd6" compoundref="tlsf_8hpp" startline="538" endline="538">dsa::TLSF&lt; 5 &gt;::max_block_size</references>
        <references refid="classdsa_1_1e_alloc_1a00bb3a88d7fd0f8148deb3a0786a9d64" compoundref="e_alloc_8hpp" startline="35">MAX_POOL</references>
        <references refid="classdsa_1_1e_alloc_1a029fe4dad4712ad2f5137c5ec15c9449" compoundref="e_alloc_8hpp" startline="232">memory_pools</references>
        <references refid="classdsa_1_1_t_l_s_f_1a89ba8da1eed88f7ce1540d3b8dbfb10b" compoundref="tlsf_8hpp" startline="537" endline="537">dsa::TLSF&lt; 5 &gt;::min_block_size</references>
        <references refid="classdsa_1_1_t_l_s_f_1abc81913bafee4d307d838896319a0ca1" compoundref="tlsf_8hpp" startline="162" endline="165">dsa::TLSF&lt; 5 &gt;::offset_to_block_nc</references>
        <references refid="classdsa_1_1e_alloc_1a814a2f70aa21ae4ecdb1caf09a368cbe" compoundref="e_alloc_8hpp" startline="234">pool_count</references>
        <references refid="classdsa_1_1_t_l_s_f_1a5d88bfb8ba87a80e7f69cf7e02a40244" compoundref="tlsf_8hpp" startline="539" endline="539">dsa::TLSF&lt; 5 &gt;::pool_overhead</references>
        <references refid="classdsa_1_1e_alloc_1ab191339864ad951a9b4174ed766ad024" compoundref="e_alloc_8hpp" startline="233">pool_sizes</references>
        <references refid="classdsa_1_1_t_l_s_f_1a5b817e5a0872cac294950e321bdf75ea" compoundref="tlsf_8hpp" startline="119" endline="119">dsa::TLSF&lt; 5 &gt;::set_free</references>
        <references refid="classdsa_1_1_t_l_s_f_1a8fa3eb30d8636dfb48c02ca7860ec733" compoundref="tlsf_8hpp" startline="123" endline="123">dsa::TLSF&lt; 5 &gt;::set_prev_free</references>
        <references refid="classdsa_1_1_t_l_s_f_1a4fd943d469f8d3be81ba66e109f8340f" compoundref="tlsf_8hpp" startline="124" endline="127">dsa::TLSF&lt; 5 &gt;::set_prev_used</references>
        <references refid="classdsa_1_1_t_l_s_f_1af56ea62a64a94a3620be635004a433b4" compoundref="tlsf_8hpp" startline="103" endline="106">dsa::TLSF&lt; 5 &gt;::set_size</references>
        <references refid="classdsa_1_1_t_l_s_f_1a72f2bfdf752ce60b3af7301ea029bffb" compoundref="tlsf_8hpp" startline="121" endline="121">dsa::TLSF&lt; 5 &gt;::set_used</references>
        <references refid="namespace_l_o_g_1a9a5ec8f75979677739eddc5e1e61c043ad0749aaba8b833466dfcbb0428e4f89c" compoundref="_logger_8hpp" startline="20">LOG::SUCCESS</references>
        <referencedby refid="classdsa_1_1e_alloc_1aca9cba9a8b6174888e0774a6e9e92a36" compoundref="e_alloc_8cpp" startline="12" endline="21">eAlloc</referencedby>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1e_alloc_1a8d029b14252fb77d1c2d5311b483abda" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void dsa::eAlloc::remove_pool</definition>
        <argsstring>(void *pool)</argsstring>
        <name>remove_pool</name>
        <qualifiedname>dsa::eAlloc::remove_pool</qualifiedname>
        <param>
          <type>void *</type>
          <declname>pool</declname>
        </param>
        <briefdescription>
<para>Removes a memory pool from the allocator. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pool</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the pool to remove. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>The pool must contain no allocated blocks; all memory allocated from it must be freed prior to removal, or undefined behavior will result. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/eAlloc.hpp" line="188" column="10" bodyfile="src/eAlloc.cpp" bodystart="79" bodyend="110"/>
        <references refid="classdsa_1_1_t_l_s_f_1a1e7328266ccc90058b455aea1ba93746" compoundref="tlsf_8hpp" startline="540" endline="540">dsa::TLSF&lt; 5 &gt;::alloc_overhead</references>
        <references refid="classdsa_1_1e_alloc_1acede9859339f8409d85c7a14cd71f6f2" compoundref="e_alloc_8hpp" startline="231">control</references>
        <references refid="classdsa_1_1e_alloc_1a69c9c5fe21b83dd7f8ae293395d1f21a" compoundref="e_alloc_8hpp" startline="236">elock_</references>
        <references refid="namespace_l_o_g_1a9a5ec8f75979677739eddc5e1e61c043abb1ca97ec761fc37101737ba0aa2e7c5" compoundref="_logger_8hpp" startline="22">LOG::ERROR</references>
        <references refid="classdsa_1_1_t_l_s_f_1aa3b06851f567dc4366f71faf793d278c" compoundref="tlsf_8hpp" startline="98" endline="101">dsa::TLSF&lt; 5 &gt;::get_size</references>
        <references refid="namespace_l_o_g_1a9a5ec8f75979677739eddc5e1e61c043a551b723eafd6a31d444fcb2f5920fbd3" compoundref="_logger_8hpp" startline="19">LOG::INFO</references>
        <references refid="classdsa_1_1_t_l_s_f_1a1c60aa4b3b12526b95628d9dba0c95be" compoundref="tlsf_8hpp" startline="108" endline="111">dsa::TLSF&lt; 5 &gt;::is_free</references>
        <references refid="classdsa_1_1_t_l_s_f_1adcbc2cc8ec2a8e348b2f7c12fb74c013" compoundref="tlsf_8hpp" startline="117" endline="117">dsa::TLSF&lt; 5 &gt;::is_last</references>
        <references refid="classdsa_1_1_t_l_s_f_1a7aaa27582e40b9eabb7d4c03c5facb04" compoundref="tlsf_8hpp" startline="248" endline="265">dsa::TLSF&lt; 5 &gt;::mapping_insert</references>
        <references refid="classdsa_1_1e_alloc_1a029fe4dad4712ad2f5137c5ec15c9449" compoundref="e_alloc_8hpp" startline="232">memory_pools</references>
        <references refid="classdsa_1_1_t_l_s_f_1a95fb2325991390b7e21889d5f212e231" compoundref="tlsf_8hpp" startline="175" endline="181">dsa::TLSF&lt; 5 &gt;::next</references>
        <references refid="classdsa_1_1_t_l_s_f_1abc81913bafee4d307d838896319a0ca1" compoundref="tlsf_8hpp" startline="162" endline="165">dsa::TLSF&lt; 5 &gt;::offset_to_block_nc</references>
        <references refid="classdsa_1_1e_alloc_1a814a2f70aa21ae4ecdb1caf09a368cbe" compoundref="e_alloc_8hpp" startline="234">pool_count</references>
        <references refid="classdsa_1_1e_alloc_1ab191339864ad951a9b4174ed766ad024" compoundref="e_alloc_8hpp" startline="233">pool_sizes</references>
        <references refid="classdsa_1_1_t_l_s_f_1a57e28078474fdc0853060430d5454920" compoundref="tlsf_8hpp" startline="298" endline="316">dsa::TLSF&lt; 5 &gt;::remove_free_block</references>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1e_alloc_1a90897aee2f774c0dd1d4267465394cb5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int dsa::eAlloc::check_pool</definition>
        <argsstring>(void *pool)</argsstring>
        <name>check_pool</name>
        <qualifiedname>dsa::eAlloc::check_pool</qualifiedname>
        <param>
          <type>void *</type>
          <declname>pool</declname>
        </param>
        <briefdescription>
<para>Checks the integrity of a specific memory pool. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pool</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the pool to check. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Integrity status (0 if intact, non-zero if issues found). </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/eAlloc.hpp" line="195" column="9" bodyfile="src/eAlloc.cpp" bodystart="114" bodyend="119"/>
        <references refid="classdsa_1_1e_alloc_1a8dbde398ec79c50e4bec8cb34c237760" compoundref="e_alloc_8cpp" startline="123" endline="137">integrity_walker</references>
        <references refid="structdsa_1_1e_alloc_1_1_integrity_result_1a189458b4e661e866fc5993a44c6b4936" compoundref="e_alloc_8hpp" startline="50">dsa::eAlloc::IntegrityResult::status</references>
        <references refid="classdsa_1_1e_alloc_1a799fb29ed4b5e3d4ab9a69cef933576a" compoundref="e_alloc_8cpp" startline="165" endline="175">walk_pool</references>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1e_alloc_1a024bc4fbaab369234c4569a36c15b300" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void *</type>
        <definition>void * dsa::eAlloc::get_pool</definition>
        <argsstring>(void *pool)</argsstring>
        <name>get_pool</name>
        <qualifiedname>dsa::eAlloc::get_pool</qualifiedname>
        <param>
          <type>void *</type>
          <declname>pool</declname>
        </param>
        <briefdescription>
<para>Retrieves the usable memory pointer of a pool. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pool</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the pool. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Pointer to the pool&apos;s usable memory. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/eAlloc.hpp" line="202" column="10" bodyfile="src/eAlloc.cpp" bodystart="112" bodyend="112"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1e_alloc_1ad1f088a6a6ac5997e224ad0062c70523" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int dsa::eAlloc::check</definition>
        <argsstring>()</argsstring>
        <name>check</name>
        <qualifiedname>dsa::eAlloc::check</qualifiedname>
        <briefdescription>
<para>Checks the overall integrity of the allocator. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>Integrity status (0 if intact, non-zero if issues found). </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/eAlloc.hpp" line="208" column="9" bodyfile="src/eAlloc.cpp" bodystart="121" bodyend="121"/>
        <references refid="classdsa_1_1_t_l_s_f_1aaed5056de4768b8781b5c29d0ce257c6" compoundref="tlsf_8hpp" startline="480" endline="529">dsa::TLSF&lt; 5 &gt;::check</references>
        <references refid="classdsa_1_1e_alloc_1acede9859339f8409d85c7a14cd71f6f2" compoundref="e_alloc_8hpp" startline="231">control</references>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1e_alloc_1aabc4d2a1849719c8c1a136262ef7f681" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structdsa_1_1e_alloc_1_1_storage_report" kindref="compound">StorageReport</ref></type>
        <definition>eAlloc::StorageReport dsa::eAlloc::report</definition>
        <argsstring>() const</argsstring>
        <name>report</name>
        <qualifiedname>dsa::eAlloc::report</qualifiedname>
        <briefdescription>
<para>Generates a storage usage report. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para><ref refid="structdsa_1_1e_alloc_1_1_storage_report" kindref="compound">StorageReport</ref> containing free space and fragmentation details. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/eAlloc.hpp" line="223" column="19" bodyfile="src/eAlloc.cpp" bodystart="293" bodyend="325"/>
        <references refid="classdsa_1_1_t_l_s_f_1ab1504ff0e4c8fc95be7a591016c1bcdb" compoundref="tlsf_8hpp" startline="532" endline="532">dsa::TLSF&lt; 5 &gt;::cabinets</references>
        <references refid="classdsa_1_1e_alloc_1acede9859339f8409d85c7a14cd71f6f2" compoundref="e_alloc_8hpp" startline="231">control</references>
        <references refid="classdsa_1_1e_alloc_1a69c9c5fe21b83dd7f8ae293395d1f21a" compoundref="e_alloc_8hpp" startline="236">elock_</references>
        <references refid="classdsa_1_1_t_l_s_f_1aa3b06851f567dc4366f71faf793d278c" compoundref="tlsf_8hpp" startline="98" endline="101">dsa::TLSF&lt; 5 &gt;::get_size</references>
        <references refid="classdsa_1_1e_alloc_1aabc4d2a1849719c8c1a136262ef7f681" compoundref="e_alloc_8cpp" startline="293" endline="325">report</references>
        <references refid="classdsa_1_1_t_l_s_f_1ab40635b4daeb1e0327e1760e31511a80" compoundref="tlsf_8hpp" startline="533" endline="533">dsa::TLSF&lt; 5 &gt;::shelves</references>
        <referencedby refid="classdsa_1_1e_alloc_1ab6eca8ea2b15b265e560e88d938adec3" compoundref="e_alloc_8cpp" startline="327" endline="335">logStorageReport</referencedby>
        <referencedby refid="classdsa_1_1e_alloc_1aabc4d2a1849719c8c1a136262ef7f681" compoundref="e_alloc_8cpp" startline="293" endline="325">report</referencedby>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1e_alloc_1ab6eca8ea2b15b265e560e88d938adec3" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void dsa::eAlloc::logStorageReport</definition>
        <argsstring>() const</argsstring>
        <name>logStorageReport</name>
        <qualifiedname>dsa::eAlloc::logStorageReport</qualifiedname>
        <briefdescription>
<para>Logs the storage usage report. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/eAlloc.hpp" line="228" column="10" bodyfile="src/eAlloc.cpp" bodystart="327" bodyend="335"/>
        <references refid="structdsa_1_1e_alloc_1_1_storage_report_1aac10fcf726b114c1b865a8f5937408da" compoundref="e_alloc_8hpp" startline="64">dsa::eAlloc::StorageReport::fragmentationFactor</references>
        <references refid="structdsa_1_1e_alloc_1_1_storage_report_1aad2065fb616b756e0cd63ece53b70085" compoundref="e_alloc_8hpp" startline="63">dsa::eAlloc::StorageReport::freeBlockCount</references>
        <references refid="namespace_l_o_g_1a9a5ec8f75979677739eddc5e1e61c043a551b723eafd6a31d444fcb2f5920fbd3" compoundref="_logger_8hpp" startline="19">LOG::INFO</references>
        <references refid="structdsa_1_1e_alloc_1_1_storage_report_1a6f5d727121d4711576e5b36ff38c337c" compoundref="e_alloc_8hpp" startline="62">dsa::eAlloc::StorageReport::largestFreeRegion</references>
        <references refid="classdsa_1_1e_alloc_1aabc4d2a1849719c8c1a136262ef7f681" compoundref="e_alloc_8cpp" startline="293" endline="325">report</references>
        <references refid="structdsa_1_1e_alloc_1_1_storage_report_1aafeefd79a7a5bee5ab538e9bb9feb539" compoundref="e_alloc_8hpp" startline="61">dsa::eAlloc::StorageReport::totalFreeSpace</references>
      </memberdef>
    </sectiondef>
    <sectiondef kind="public-static-func">
      <memberdef kind="function" id="classdsa_1_1e_alloc_1a8dbde398ec79c50e4bec8cb34c237760" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void dsa::eAlloc::integrity_walker</definition>
        <argsstring>(void *ptr, size_t size, int used, void *user)</argsstring>
        <name>integrity_walker</name>
        <qualifiedname>dsa::eAlloc::integrity_walker</qualifiedname>
        <param>
          <type>void *</type>
          <declname>ptr</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>size</declname>
        </param>
        <param>
          <type>int</type>
          <declname>used</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>user</declname>
        </param>
        <briefdescription>
<para><ref refid="classdsa_1_1e_alloc_1a50adb94983befce215dcff2aecfab2f4" kindref="member">Walker</ref> function for integrity checks. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ptr</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the block. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>Size of the block in bytes. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>used</parametername>
</parameternamelist>
<parameterdescription>
<para>Flag indicating if the block is used (non-zero) or free (0). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>user</parametername>
</parameternamelist>
<parameterdescription>
<para>User-defined data passed to the walker. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/eAlloc.hpp" line="217" column="17" bodyfile="src/eAlloc.cpp" bodystart="123" bodyend="137"/>
        <references refid="tlsf_8hpp_1a7f176a9edf6585122465fae7a0a49fef" compoundref="tlsf_8hpp" startline="13" endline="20">dsa_insist</references>
        <references refid="classdsa_1_1_t_l_s_f_1afd2921b2dac73664c9bdadff7abd6eb6" compoundref="tlsf_8hpp" startline="151" endline="155">dsa::TLSF&lt; 5 &gt;::from_ptr_nc</references>
        <references refid="classdsa_1_1_t_l_s_f_1aa3b06851f567dc4366f71faf793d278c" compoundref="tlsf_8hpp" startline="98" endline="101">dsa::TLSF&lt; 5 &gt;::get_size</references>
        <references refid="classdsa_1_1_t_l_s_f_1a1c60aa4b3b12526b95628d9dba0c95be" compoundref="tlsf_8hpp" startline="108" endline="111">dsa::TLSF&lt; 5 &gt;::is_free</references>
        <references refid="classdsa_1_1_t_l_s_f_1ac45a129e8e6228e0360fbc191652e9a6" compoundref="tlsf_8hpp" startline="112" endline="115">dsa::TLSF&lt; 5 &gt;::is_prev_free</references>
        <references refid="structdsa_1_1e_alloc_1_1_integrity_result_1a3ed875c17b3a7888028d1b68c448cfa7" compoundref="e_alloc_8hpp" startline="49">dsa::eAlloc::IntegrityResult::prev_status</references>
        <references refid="structdsa_1_1e_alloc_1_1_integrity_result_1a189458b4e661e866fc5993a44c6b4936" compoundref="e_alloc_8hpp" startline="50">dsa::eAlloc::IntegrityResult::status</references>
        <referencedby refid="classdsa_1_1e_alloc_1a90897aee2f774c0dd1d4267465394cb5" compoundref="e_alloc_8cpp" startline="114" endline="119">check_pool</referencedby>
      </memberdef>
    </sectiondef>
    <sectiondef kind="private-func">
      <memberdef kind="function" id="classdsa_1_1e_alloc_1a799fb29ed4b5e3d4ab9a69cef933576a" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void dsa::eAlloc::walk_pool</definition>
        <argsstring>(void *pool, Walker walker, void *user)</argsstring>
        <name>walk_pool</name>
        <qualifiedname>dsa::eAlloc::walk_pool</qualifiedname>
        <param>
          <type>void *</type>
          <declname>pool</declname>
        </param>
        <param>
          <type><ref refid="classdsa_1_1e_alloc_1a50adb94983befce215dcff2aecfab2f4" kindref="member">Walker</ref></type>
          <declname>walker</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>user</declname>
        </param>
        <briefdescription>
<para>Walks through the blocks in a pool with a specified walker function. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pool</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the pool to walk. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>walker</parametername>
</parameternamelist>
<parameterdescription>
<para>Function to apply to each block. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>user</parametername>
</parameternamelist>
<parameterdescription>
<para>User-defined data passed to the walker. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/eAlloc.hpp" line="243" column="10" bodyfile="src/eAlloc.cpp" bodystart="165" bodyend="175"/>
        <references refid="classdsa_1_1_t_l_s_f_1a1e7328266ccc90058b455aea1ba93746" compoundref="tlsf_8hpp" startline="540" endline="540">dsa::TLSF&lt; 5 &gt;::alloc_overhead</references>
        <references refid="classdsa_1_1_t_l_s_f_1af06d06e73cb9a3a3a4c48e2016ab5dc4" compoundref="tlsf_8hpp" startline="473" endline="478">dsa::TLSF&lt; 5 &gt;::default_walker</references>
        <references refid="classdsa_1_1e_alloc_1a69c9c5fe21b83dd7f8ae293395d1f21a" compoundref="e_alloc_8hpp" startline="236">elock_</references>
        <references refid="classdsa_1_1_t_l_s_f_1aa3b06851f567dc4366f71faf793d278c" compoundref="tlsf_8hpp" startline="98" endline="101">dsa::TLSF&lt; 5 &gt;::get_size</references>
        <references refid="classdsa_1_1_t_l_s_f_1a1c60aa4b3b12526b95628d9dba0c95be" compoundref="tlsf_8hpp" startline="108" endline="111">dsa::TLSF&lt; 5 &gt;::is_free</references>
        <references refid="classdsa_1_1_t_l_s_f_1adcbc2cc8ec2a8e348b2f7c12fb74c013" compoundref="tlsf_8hpp" startline="117" endline="117">dsa::TLSF&lt; 5 &gt;::is_last</references>
        <references refid="classdsa_1_1_t_l_s_f_1a95fb2325991390b7e21889d5f212e231" compoundref="tlsf_8hpp" startline="175" endline="181">dsa::TLSF&lt; 5 &gt;::next</references>
        <references refid="classdsa_1_1_t_l_s_f_1abc81913bafee4d307d838896319a0ca1" compoundref="tlsf_8hpp" startline="162" endline="165">dsa::TLSF&lt; 5 &gt;::offset_to_block_nc</references>
        <references refid="classdsa_1_1_t_l_s_f_1a695ec978573cffb0ab2b9d9e28068e02" compoundref="tlsf_8hpp" startline="141" endline="145">dsa::TLSF&lt; 5 &gt;::to_ptr_nc</references>
        <referencedby refid="classdsa_1_1e_alloc_1a90897aee2f774c0dd1d4267465394cb5" compoundref="e_alloc_8cpp" startline="114" endline="119">check_pool</referencedby>
      </memberdef>
    </sectiondef>
    <briefdescription>
<para>A memory allocator class based on the Two-Level Segregated Fit (<ref refid="classdsa_1_1_t_l_s_f" kindref="compound">TLSF</ref>) algorithm. </para>
    </briefdescription>
    <detaileddescription>
<para>The <ref refid="classdsa_1_1e_alloc" kindref="compound">eAlloc</ref> class provides efficient memory management with support for multiple pools, alignment, reallocation, and storage reporting. </para>
    </detaileddescription>
    <collaborationgraph>
      <node id="2">
        <label>dsa::TLSF&lt; 5 &gt;::Control</label>
      </node>
      <node id="1">
        <label>dsa::eAlloc</label>
        <link refid="classdsa_1_1e_alloc"/>
        <childnode refid="2" relation="usage">
          <edgelabel>control</edgelabel>
        </childnode>
      </node>
    </collaborationgraph>
    <location file="src/eAlloc.hpp" line="32" column="1" bodyfile="src/eAlloc.hpp" bodystart="33" bodyend="244"/>
    <listofallmembers>
      <member refid="classdsa_1_1e_alloc_1a430864385c853363d2c44678d00e0f95" prot="public" virt="non-virtual"><scope>dsa::eAlloc</scope><name>add_pool</name></member>
      <member refid="classdsa_1_1e_alloc_1a1c4355fbb45c0c0876a97a1bb2515f68" prot="public" virt="non-virtual"><scope>dsa::eAlloc</scope><name>allocate</name></member>
      <member refid="classdsa_1_1e_alloc_1a3cbe14b74b41cd912af2c4c2b277196b" prot="public" virt="non-virtual"><scope>dsa::eAlloc</scope><name>allocate</name></member>
      <member refid="classdsa_1_1e_alloc_1a3dabd178fc159716de6dd7c041eb17b0" prot="public" virt="non-virtual"><scope>dsa::eAlloc</scope><name>BlockHeader</name></member>
      <member refid="classdsa_1_1e_alloc_1a01a9d3be9b919029d0d5bda73f56757c" prot="public" virt="non-virtual"><scope>dsa::eAlloc</scope><name>calloc</name></member>
      <member refid="classdsa_1_1e_alloc_1ad1f088a6a6ac5997e224ad0062c70523" prot="public" virt="non-virtual"><scope>dsa::eAlloc</scope><name>check</name></member>
      <member refid="classdsa_1_1e_alloc_1a90897aee2f774c0dd1d4267465394cb5" prot="public" virt="non-virtual"><scope>dsa::eAlloc</scope><name>check_pool</name></member>
      <member refid="classdsa_1_1e_alloc_1acbf770d2d9ab8ceb8df2a935a82eea10" prot="public" virt="non-virtual"><scope>dsa::eAlloc</scope><name>Control</name></member>
      <member refid="classdsa_1_1e_alloc_1acede9859339f8409d85c7a14cd71f6f2" prot="private" virt="non-virtual"><scope>dsa::eAlloc</scope><name>control</name></member>
      <member refid="classdsa_1_1e_alloc_1a142ecbc514fb8d9618fee741dece6efc" prot="public" virt="non-virtual"><scope>dsa::eAlloc</scope><name>deallocate</name></member>
      <member refid="classdsa_1_1e_alloc_1aca9cba9a8b6174888e0774a6e9e92a36" prot="public" virt="non-virtual"><scope>dsa::eAlloc</scope><name>eAlloc</name></member>
      <member refid="classdsa_1_1e_alloc_1a69c9c5fe21b83dd7f8ae293395d1f21a" prot="private" virt="non-virtual"><scope>dsa::eAlloc</scope><name>elock_</name></member>
      <member refid="classdsa_1_1e_alloc_1a6cf6ea0950ef6c2c4d496a92c4786282" prot="public" virt="non-virtual"><scope>dsa::eAlloc</scope><name>free</name></member>
      <member refid="classdsa_1_1e_alloc_1a024bc4fbaab369234c4569a36c15b300" prot="public" virt="non-virtual"><scope>dsa::eAlloc</scope><name>get_pool</name></member>
      <member refid="classdsa_1_1e_alloc_1a5db3dffebe3e135f6629a128177ffa9e" prot="private" virt="non-virtual"><scope>dsa::eAlloc</scope><name>initialised</name></member>
      <member refid="classdsa_1_1e_alloc_1a8dbde398ec79c50e4bec8cb34c237760" prot="public" virt="non-virtual"><scope>dsa::eAlloc</scope><name>integrity_walker</name></member>
      <member refid="classdsa_1_1e_alloc_1ab6eca8ea2b15b265e560e88d938adec3" prot="public" virt="non-virtual"><scope>dsa::eAlloc</scope><name>logStorageReport</name></member>
      <member refid="classdsa_1_1e_alloc_1a5faaeb302c059421ca82cfc7db8e9879" prot="public" virt="non-virtual"><scope>dsa::eAlloc</scope><name>malloc</name></member>
      <member refid="classdsa_1_1e_alloc_1a00bb3a88d7fd0f8148deb3a0786a9d64" prot="public" virt="non-virtual"><scope>dsa::eAlloc</scope><name>MAX_POOL</name></member>
      <member refid="classdsa_1_1e_alloc_1ad55296e9a38ece48f061fd23b8fb1738" prot="public" virt="non-virtual"><scope>dsa::eAlloc</scope><name>memalign</name></member>
      <member refid="classdsa_1_1e_alloc_1a029fe4dad4712ad2f5137c5ec15c9449" prot="private" virt="non-virtual"><scope>dsa::eAlloc</scope><name>memory_pools</name></member>
      <member refid="classdsa_1_1e_alloc_1a814a2f70aa21ae4ecdb1caf09a368cbe" prot="private" virt="non-virtual"><scope>dsa::eAlloc</scope><name>pool_count</name></member>
      <member refid="classdsa_1_1e_alloc_1ab191339864ad951a9b4174ed766ad024" prot="private" virt="non-virtual"><scope>dsa::eAlloc</scope><name>pool_sizes</name></member>
      <member refid="classdsa_1_1e_alloc_1a56c8d1f3e2368a15361968596b335eeb" prot="public" virt="non-virtual"><scope>dsa::eAlloc</scope><name>realloc</name></member>
      <member refid="classdsa_1_1e_alloc_1a8d029b14252fb77d1c2d5311b483abda" prot="public" virt="non-virtual"><scope>dsa::eAlloc</scope><name>remove_pool</name></member>
      <member refid="classdsa_1_1e_alloc_1aabc4d2a1849719c8c1a136262ef7f681" prot="public" virt="non-virtual"><scope>dsa::eAlloc</scope><name>report</name></member>
      <member refid="classdsa_1_1e_alloc_1a0763696d9c6e5c93459ae6eeea137830" prot="public" virt="non-virtual"><scope>dsa::eAlloc</scope><name>setELock</name></member>
      <member refid="classdsa_1_1e_alloc_1ae788e9d3eb03abbd532ef5ce3477edab" prot="public" virt="non-virtual"><scope>dsa::eAlloc</scope><name>tlsf</name></member>
      <member refid="classdsa_1_1e_alloc_1a799fb29ed4b5e3d4ab9a69cef933576a" prot="private" virt="non-virtual"><scope>dsa::eAlloc</scope><name>walk_pool</name></member>
      <member refid="classdsa_1_1e_alloc_1a50adb94983befce215dcff2aecfab2f4" prot="public" virt="non-virtual"><scope>dsa::eAlloc</scope><name>Walker</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
