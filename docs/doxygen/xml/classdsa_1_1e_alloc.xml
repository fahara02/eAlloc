<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.13.2" xml:lang="en-US">
  <compounddef id="classdsa_1_1e_alloc" kind="class" language="C++" prot="public">
    <compoundname>dsa::eAlloc</compoundname>
    <includes refid="e_alloc_8hpp" local="no">eAlloc.hpp</includes>
    <innerclass refid="structdsa_1_1e_alloc_1_1_integrity_result" prot="public">dsa::eAlloc::IntegrityResult</innerclass>
    <innerclass refid="structdsa_1_1e_alloc_1_1_storage_report" prot="public">dsa::eAlloc::StorageReport</innerclass>
    <sectiondef kind="public-type">
      <memberdef kind="typedef" id="classdsa_1_1e_alloc_1ae788e9d3eb03abbd532ef5ce3477edab" prot="public" static="no">
        <type><ref refid="classdsa_1_1_t_l_s_f" kindref="compound">dsa::TLSF</ref>&lt; 5 &gt;</type>
        <definition>using dsa::eAlloc::tlsf =  dsa::TLSF&lt;5&gt;</definition>
        <argsstring></argsstring>
        <name>tlsf</name>
        <qualifiedname>dsa::eAlloc::tlsf</qualifiedname>
        <briefdescription>
<para><ref refid="classdsa_1_1_t_l_s_f" kindref="compound">TLSF</ref> allocator with 32 second-level lists. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/eAlloc.hpp" line="53" column="5" bodyfile="src/eAlloc.hpp" bodystart="53" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classdsa_1_1e_alloc_1acbf770d2d9ab8ceb8df2a935a82eea10" prot="public" static="no">
        <type>tlsf::Control</type>
        <definition>using dsa::eAlloc::Control =  tlsf::Control</definition>
        <argsstring></argsstring>
        <name>Control</name>
        <qualifiedname>dsa::eAlloc::Control</qualifiedname>
        <briefdescription>
<para><ref refid="classdsa_1_1_t_l_s_f" kindref="compound">TLSF</ref> control structure type. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/eAlloc.hpp" line="54" column="5" bodyfile="src/eAlloc.hpp" bodystart="54" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classdsa_1_1e_alloc_1a3dabd178fc159716de6dd7c041eb17b0" prot="public" static="no">
        <type>tlsf::BlockHeader</type>
        <definition>using dsa::eAlloc::BlockHeader =  tlsf::BlockHeader</definition>
        <argsstring></argsstring>
        <name>BlockHeader</name>
        <qualifiedname>dsa::eAlloc::BlockHeader</qualifiedname>
        <briefdescription>
<para><ref refid="classdsa_1_1_t_l_s_f" kindref="compound">TLSF</ref> block header type. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/eAlloc.hpp" line="55" column="5" bodyfile="src/eAlloc.hpp" bodystart="55" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classdsa_1_1e_alloc_1a50adb94983befce215dcff2aecfab2f4" prot="public" static="no">
        <type><ref refid="classdsa_1_1_t_l_s_f_1ac2e907fdaba5c8fc4c9185a632d8efe6" kindref="member">tlsf::tlsf_walker</ref></type>
        <definition>using dsa::eAlloc::Walker =  tlsf::tlsf_walker</definition>
        <argsstring></argsstring>
        <name>Walker</name>
        <qualifiedname>dsa::eAlloc::Walker</qualifiedname>
        <briefdescription>
<para>Function type for walking memory blocks. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/eAlloc.hpp" line="56" column="5" bodyfile="src/eAlloc.hpp" bodystart="56" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="public-static-attrib">
      <memberdef kind="variable" id="classdsa_1_1e_alloc_1a00bb3a88d7fd0f8148deb3a0786a9d64" prot="public" static="yes" constexpr="yes" mutable="no">
        <type>size_t</type>
        <definition>size_t dsa::eAlloc::MAX_POOL</definition>
        <argsstring></argsstring>
        <name>MAX_POOL</name>
        <qualifiedname>dsa::eAlloc::MAX_POOL</qualifiedname>
        <initializer>= 5</initializer>
        <briefdescription>
<para>Maximum number of memory pools allowed. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/eAlloc.hpp" line="35" column="29" bodyfile="src/eAlloc.hpp" bodystart="35" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="private-attrib">
      <memberdef kind="variable" id="classdsa_1_1e_alloc_1acede9859339f8409d85c7a14cd71f6f2" prot="private" static="no" mutable="no">
        <type><ref refid="classdsa_1_1e_alloc_1acbf770d2d9ab8ceb8df2a935a82eea10" kindref="member">Control</ref></type>
        <definition>Control dsa::eAlloc::control</definition>
        <argsstring></argsstring>
        <name>control</name>
        <qualifiedname>dsa::eAlloc::control</qualifiedname>
        <briefdescription>
<para><ref refid="classdsa_1_1_t_l_s_f" kindref="compound">TLSF</ref> control structure. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/eAlloc.hpp" line="241" column="13" bodyfile="src/eAlloc.hpp" bodystart="241" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classdsa_1_1e_alloc_1a029fe4dad4712ad2f5137c5ec15c9449" prot="private" static="no" mutable="no">
        <type>void *</type>
        <definition>void* dsa::eAlloc::memory_pools[MAX_POOL]</definition>
        <argsstring>[MAX_POOL]</argsstring>
        <name>memory_pools</name>
        <qualifiedname>dsa::eAlloc::memory_pools</qualifiedname>
        <briefdescription>
<para>Array of memory pool pointers. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/eAlloc.hpp" line="242" column="10" bodyfile="src/eAlloc.hpp" bodystart="242" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classdsa_1_1e_alloc_1ab191339864ad951a9b4174ed766ad024" prot="private" static="no" mutable="no">
        <type>size_t</type>
        <definition>size_t dsa::eAlloc::pool_sizes[MAX_POOL]</definition>
        <argsstring>[MAX_POOL]</argsstring>
        <name>pool_sizes</name>
        <qualifiedname>dsa::eAlloc::pool_sizes</qualifiedname>
        <briefdescription>
<para>store all pool sizes </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/eAlloc.hpp" line="243" column="12" bodyfile="src/eAlloc.hpp" bodystart="243" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classdsa_1_1e_alloc_1a814a2f70aa21ae4ecdb1caf09a368cbe" prot="private" static="no" mutable="no">
        <type>size_t</type>
        <definition>size_t dsa::eAlloc::pool_count</definition>
        <argsstring></argsstring>
        <name>pool_count</name>
        <qualifiedname>dsa::eAlloc::pool_count</qualifiedname>
        <initializer>= 0</initializer>
        <briefdescription>
<para>Number of active pools. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/eAlloc.hpp" line="244" column="12" bodyfile="src/eAlloc.hpp" bodystart="244" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classdsa_1_1e_alloc_1a5db3dffebe3e135f6629a128177ffa9e" prot="private" static="no" mutable="no">
        <type>bool</type>
        <definition>bool dsa::eAlloc::initialised</definition>
        <argsstring></argsstring>
        <name>initialised</name>
        <qualifiedname>dsa::eAlloc::initialised</qualifiedname>
        <initializer>= false</initializer>
        <briefdescription>
<para>Flag indicating if the allocator is initialized. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/eAlloc.hpp" line="245" column="10" bodyfile="src/eAlloc.hpp" bodystart="245" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classdsa_1_1e_alloc_1aa237d516ee699b332e8fb5985bb7e643" prot="private" static="no" mutable="no">
        <type><ref refid="classelock_1_1_i_lockable" kindref="compound">elock::ILockable</ref> *</type>
        <definition>elock::ILockable* dsa::eAlloc::lock_</definition>
        <argsstring></argsstring>
        <name>lock_</name>
        <qualifiedname>dsa::eAlloc::lock_</qualifiedname>
        <initializer>= nullptr</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/eAlloc.hpp" line="246" column="22" bodyfile="src/eAlloc.hpp" bodystart="246" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="public-func">
      <memberdef kind="function" id="classdsa_1_1e_alloc_1a97fb67f4bb3ca8802b00f51935f954b7" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void dsa::eAlloc::setLock</definition>
        <argsstring>(elock::ILockable *lock)</argsstring>
        <name>setLock</name>
        <qualifiedname>dsa::eAlloc::setLock</qualifiedname>
        <param>
          <type><ref refid="classelock_1_1_i_lockable" kindref="compound">elock::ILockable</ref> *</type>
          <declname>lock</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/eAlloc.hpp" line="37" column="10" bodyfile="src/eAlloc.hpp" bodystart="37" bodyend="37"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1e_alloc_1aca9cba9a8b6174888e0774a6e9e92a36" prot="public" static="no" const="no" explicit="yes" inline="no" virt="non-virtual">
        <type></type>
        <definition>dsa::eAlloc::eAlloc</definition>
        <argsstring>(void *mem, size_t bytes)</argsstring>
        <name>eAlloc</name>
        <qualifiedname>dsa::eAlloc::eAlloc</qualifiedname>
        <param>
          <type>void *</type>
          <declname>mem</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>bytes</declname>
        </param>
        <briefdescription>
<para>Constructs an <ref refid="classdsa_1_1e_alloc" kindref="compound">eAlloc</ref> instance with an initial memory pool. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mem</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the initial memory block. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bytes</parametername>
</parameternamelist>
<parameterdescription>
<para>Size of the initial memory block in bytes. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/eAlloc.hpp" line="44" column="14" bodyfile="src/eAlloc.cpp" bodystart="12" bodyend="21"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1e_alloc_1a5faaeb302c059421ca82cfc7db8e9879" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void *</type>
        <definition>void * dsa::eAlloc::malloc</definition>
        <argsstring>(size_t size)</argsstring>
        <name>malloc</name>
        <qualifiedname>dsa::eAlloc::malloc</qualifiedname>
        <param>
          <type>size_t</type>
          <declname>size</declname>
        </param>
        <briefdescription>
<para>Allocates a block of memory of the specified size. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>The size of the memory block to allocate in bytes. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Pointer to the allocated memory, or nullptr if allocation fails. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/eAlloc.hpp" line="82" column="10" bodyfile="src/eAlloc.cpp" bodystart="139" bodyend="145"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1e_alloc_1a6cf6ea0950ef6c2c4d496a92c4786282" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void dsa::eAlloc::free</definition>
        <argsstring>(void *ptr)</argsstring>
        <name>free</name>
        <qualifiedname>dsa::eAlloc::free</qualifiedname>
        <param>
          <type>void *</type>
          <declname>ptr</declname>
        </param>
        <briefdescription>
<para>Frees a previously allocated memory block. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ptr</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the memory block to free. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/eAlloc.hpp" line="88" column="10" bodyfile="src/eAlloc.cpp" bodystart="147" bodyend="163"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1e_alloc_1ad55296e9a38ece48f061fd23b8fb1738" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void *</type>
        <definition>void * dsa::eAlloc::memalign</definition>
        <argsstring>(size_t align, size_t size)</argsstring>
        <name>memalign</name>
        <qualifiedname>dsa::eAlloc::memalign</qualifiedname>
        <param>
          <type>size_t</type>
          <declname>align</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>size</declname>
        </param>
        <briefdescription>
<para>Allocates a memory block with specified alignment and size. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>align</parametername>
</parameternamelist>
<parameterdescription>
<para>The alignment requirement in bytes (must be a power of 2). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>The size of the memory block to allocate in bytes. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Pointer to the allocated memory, or nullptr if allocation fails. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/eAlloc.hpp" line="96" column="10" bodyfile="src/eAlloc.cpp" bodystart="177" bodyend="229"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1e_alloc_1a56c8d1f3e2368a15361968596b335eeb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void *</type>
        <definition>void * dsa::eAlloc::realloc</definition>
        <argsstring>(void *ptr, size_t size)</argsstring>
        <name>realloc</name>
        <qualifiedname>dsa::eAlloc::realloc</qualifiedname>
        <param>
          <type>void *</type>
          <declname>ptr</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>size</declname>
        </param>
        <briefdescription>
<para>Reallocates a memory block to a new size. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ptr</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the memory block to reallocate. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>The new size of the memory block in bytes. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Pointer to the reallocated memory, or nullptr if reallocation fails. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/eAlloc.hpp" line="105" column="10" bodyfile="src/eAlloc.cpp" bodystart="231" bodyend="273"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1e_alloc_1a01a9d3be9b919029d0d5bda73f56757c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void *</type>
        <definition>void * dsa::eAlloc::calloc</definition>
        <argsstring>(size_t num, size_t size)</argsstring>
        <name>calloc</name>
        <qualifiedname>dsa::eAlloc::calloc</qualifiedname>
        <param>
          <type>size_t</type>
          <declname>num</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>size</declname>
        </param>
        <briefdescription>
<para>Allocates memory for an array and initializes it to zero. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>num</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of elements in the array. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>Size of each element in bytes. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Pointer to the allocated memory, or nullptr if allocation fails. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/eAlloc.hpp" line="113" column="10" bodyfile="src/eAlloc.cpp" bodystart="275" bodyend="291"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1e_alloc_1a1c4355fbb45c0c0876a97a1bb2515f68" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>T *</type>
        <definition>T * dsa::eAlloc::allocate</definition>
        <argsstring>(const T &amp;obj)</argsstring>
        <name>allocate</name>
        <qualifiedname>dsa::eAlloc::allocate</qualifiedname>
        <param>
          <type>const T &amp;</type>
          <declname>obj</declname>
        </param>
        <briefdescription>
<para>Allocates memory for an object and constructs it by copying. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the object to allocate. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>obj</parametername>
</parameternamelist>
<parameterdescription>
<para>The object to copy-construct. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Pointer to the constructed object, or nullptr if allocation fails. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/eAlloc.hpp" line="122" column="7" bodyfile="src/eAlloc.hpp" bodystart="122" bodyend="140"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1e_alloc_1a3cbe14b74b41cd912af2c4c2b277196b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type>T *</type>
        <definition>T * dsa::eAlloc::allocate</definition>
        <argsstring>(Args &amp;&amp;... args)</argsstring>
        <name>allocate</name>
        <qualifiedname>dsa::eAlloc::allocate</qualifiedname>
        <param>
          <type>Args &amp;&amp;...</type>
          <declname>args</declname>
        </param>
        <briefdescription>
<para>Allocates memory for an object and constructs it with arguments. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the object to allocate. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Args</parametername>
</parameternamelist>
<parameterdescription>
<para>Types of the constructor arguments. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>args</parametername>
</parameternamelist>
<parameterdescription>
<para>Arguments to pass to the object&apos;s constructor. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Pointer to the constructed object, or nullptr if allocation fails. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/eAlloc.hpp" line="150" column="7" bodyfile="src/eAlloc.hpp" bodystart="150" bodyend="168"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1e_alloc_1a142ecbc514fb8d9618fee741dece6efc" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void dsa::eAlloc::deallocate</definition>
        <argsstring>(T *obj)</argsstring>
        <name>deallocate</name>
        <qualifiedname>dsa::eAlloc::deallocate</qualifiedname>
        <param>
          <type>T *</type>
          <declname>obj</declname>
        </param>
        <briefdescription>
<para>Deallocates an object and destroys it. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the object to deallocate. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>obj</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the object to deallocate. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/eAlloc.hpp" line="176" column="10" bodyfile="src/eAlloc.hpp" bodystart="176" bodyend="181"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1e_alloc_1a430864385c853363d2c44678d00e0f95" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void *</type>
        <definition>void * dsa::eAlloc::add_pool</definition>
        <argsstring>(void *mem, size_t bytes)</argsstring>
        <name>add_pool</name>
        <qualifiedname>dsa::eAlloc::add_pool</qualifiedname>
        <param>
          <type>void *</type>
          <declname>mem</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>bytes</declname>
        </param>
        <briefdescription>
<para>Adds a new memory pool to the allocator. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mem</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the memory block to add as a pool. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bytes</parametername>
</parameternamelist>
<parameterdescription>
<para>Size of the memory block in bytes. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Pointer to the added pool, or nullptr if addition fails. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/eAlloc.hpp" line="189" column="10" bodyfile="src/eAlloc.cpp" bodystart="23" bodyend="77"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1e_alloc_1a8d029b14252fb77d1c2d5311b483abda" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void dsa::eAlloc::remove_pool</definition>
        <argsstring>(void *pool)</argsstring>
        <name>remove_pool</name>
        <qualifiedname>dsa::eAlloc::remove_pool</qualifiedname>
        <param>
          <type>void *</type>
          <declname>pool</declname>
        </param>
        <briefdescription>
<para>Removes a memory pool from the allocator. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pool</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the pool to remove. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>The pool must contain no allocated blocks; all memory allocated from it must be freed prior to removal, or undefined behavior will result. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/eAlloc.hpp" line="198" column="10" bodyfile="src/eAlloc.cpp" bodystart="79" bodyend="110"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1e_alloc_1a90897aee2f774c0dd1d4267465394cb5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int dsa::eAlloc::check_pool</definition>
        <argsstring>(void *pool)</argsstring>
        <name>check_pool</name>
        <qualifiedname>dsa::eAlloc::check_pool</qualifiedname>
        <param>
          <type>void *</type>
          <declname>pool</declname>
        </param>
        <briefdescription>
<para>Checks the integrity of a specific memory pool. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pool</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the pool to check. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Integrity status (0 if intact, non-zero if issues found). </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/eAlloc.hpp" line="205" column="9" bodyfile="src/eAlloc.cpp" bodystart="114" bodyend="119"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1e_alloc_1a024bc4fbaab369234c4569a36c15b300" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void *</type>
        <definition>void * dsa::eAlloc::get_pool</definition>
        <argsstring>(void *pool)</argsstring>
        <name>get_pool</name>
        <qualifiedname>dsa::eAlloc::get_pool</qualifiedname>
        <param>
          <type>void *</type>
          <declname>pool</declname>
        </param>
        <briefdescription>
<para>Retrieves the usable memory pointer of a pool. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pool</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the pool. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Pointer to the pool&apos;s usable memory. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/eAlloc.hpp" line="212" column="10" bodyfile="src/eAlloc.cpp" bodystart="112" bodyend="112"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1e_alloc_1ad1f088a6a6ac5997e224ad0062c70523" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int dsa::eAlloc::check</definition>
        <argsstring>()</argsstring>
        <name>check</name>
        <qualifiedname>dsa::eAlloc::check</qualifiedname>
        <briefdescription>
<para>Checks the overall integrity of the allocator. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>Integrity status (0 if intact, non-zero if issues found). </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/eAlloc.hpp" line="218" column="9" bodyfile="src/eAlloc.cpp" bodystart="121" bodyend="121"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1e_alloc_1aabc4d2a1849719c8c1a136262ef7f681" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structdsa_1_1e_alloc_1_1_storage_report" kindref="compound">StorageReport</ref></type>
        <definition>eAlloc::StorageReport dsa::eAlloc::report</definition>
        <argsstring>() const</argsstring>
        <name>report</name>
        <qualifiedname>dsa::eAlloc::report</qualifiedname>
        <briefdescription>
<para>Generates a storage usage report. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para><ref refid="structdsa_1_1e_alloc_1_1_storage_report" kindref="compound">StorageReport</ref> containing free space and fragmentation details. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/eAlloc.hpp" line="233" column="19" bodyfile="src/eAlloc.cpp" bodystart="293" bodyend="325"/>
      </memberdef>
      <memberdef kind="function" id="classdsa_1_1e_alloc_1ab6eca8ea2b15b265e560e88d938adec3" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void dsa::eAlloc::logStorageReport</definition>
        <argsstring>() const</argsstring>
        <name>logStorageReport</name>
        <qualifiedname>dsa::eAlloc::logStorageReport</qualifiedname>
        <briefdescription>
<para>Logs the storage usage report. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/eAlloc.hpp" line="238" column="10" bodyfile="src/eAlloc.cpp" bodystart="327" bodyend="335"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="public-static-func">
      <memberdef kind="function" id="classdsa_1_1e_alloc_1a8dbde398ec79c50e4bec8cb34c237760" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void dsa::eAlloc::integrity_walker</definition>
        <argsstring>(void *ptr, size_t size, int used, void *user)</argsstring>
        <name>integrity_walker</name>
        <qualifiedname>dsa::eAlloc::integrity_walker</qualifiedname>
        <param>
          <type>void *</type>
          <declname>ptr</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>size</declname>
        </param>
        <param>
          <type>int</type>
          <declname>used</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>user</declname>
        </param>
        <briefdescription>
<para><ref refid="classdsa_1_1e_alloc_1a50adb94983befce215dcff2aecfab2f4" kindref="member">Walker</ref> function for integrity checks. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ptr</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the block. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>Size of the block in bytes. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>used</parametername>
</parameternamelist>
<parameterdescription>
<para>Flag indicating if the block is used (non-zero) or free (0). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>user</parametername>
</parameternamelist>
<parameterdescription>
<para>User-defined data passed to the walker. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/eAlloc.hpp" line="227" column="17" bodyfile="src/eAlloc.cpp" bodystart="123" bodyend="137"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="private-func">
      <memberdef kind="function" id="classdsa_1_1e_alloc_1a799fb29ed4b5e3d4ab9a69cef933576a" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void dsa::eAlloc::walk_pool</definition>
        <argsstring>(void *pool, Walker walker, void *user)</argsstring>
        <name>walk_pool</name>
        <qualifiedname>dsa::eAlloc::walk_pool</qualifiedname>
        <param>
          <type>void *</type>
          <declname>pool</declname>
        </param>
        <param>
          <type><ref refid="classdsa_1_1e_alloc_1a50adb94983befce215dcff2aecfab2f4" kindref="member">Walker</ref></type>
          <declname>walker</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>user</declname>
        </param>
        <briefdescription>
<para>Walks through the blocks in a pool with a specified walker function. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pool</parametername>
</parameternamelist>
<parameterdescription>
<para>Pointer to the pool to walk. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>walker</parametername>
</parameternamelist>
<parameterdescription>
<para>Function to apply to each block. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>user</parametername>
</parameternamelist>
<parameterdescription>
<para>User-defined data passed to the walker. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/eAlloc.hpp" line="253" column="10" bodyfile="src/eAlloc.cpp" bodystart="165" bodyend="175"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
<para>A memory allocator class based on the Two-Level Segregated Fit (<ref refid="classdsa_1_1_t_l_s_f" kindref="compound">TLSF</ref>) algorithm. </para>
    </briefdescription>
    <detaileddescription>
<para>The <ref refid="classdsa_1_1e_alloc" kindref="compound">eAlloc</ref> class provides efficient memory management with support for multiple pools, alignment, reallocation, and storage reporting. </para>
    </detaileddescription>
    <collaborationgraph>
      <node id="2">
        <label>dsa::TLSF&lt; 5 &gt;::Control</label>
      </node>
      <node id="1">
        <label>dsa::eAlloc</label>
        <link refid="classdsa_1_1e_alloc"/>
        <childnode refid="2" relation="usage">
          <edgelabel>control</edgelabel>
        </childnode>
        <childnode refid="3" relation="usage">
          <edgelabel>lock_</edgelabel>
        </childnode>
      </node>
      <node id="3">
        <label>elock::ILockable</label>
        <link refid="classelock_1_1_i_lockable"/>
      </node>
    </collaborationgraph>
    <location file="src/eAlloc.hpp" line="32" column="1" bodyfile="src/eAlloc.hpp" bodystart="33" bodyend="254"/>
    <listofallmembers>
      <member refid="classdsa_1_1e_alloc_1a430864385c853363d2c44678d00e0f95" prot="public" virt="non-virtual"><scope>dsa::eAlloc</scope><name>add_pool</name></member>
      <member refid="classdsa_1_1e_alloc_1a1c4355fbb45c0c0876a97a1bb2515f68" prot="public" virt="non-virtual"><scope>dsa::eAlloc</scope><name>allocate</name></member>
      <member refid="classdsa_1_1e_alloc_1a3cbe14b74b41cd912af2c4c2b277196b" prot="public" virt="non-virtual"><scope>dsa::eAlloc</scope><name>allocate</name></member>
      <member refid="classdsa_1_1e_alloc_1a3dabd178fc159716de6dd7c041eb17b0" prot="public" virt="non-virtual"><scope>dsa::eAlloc</scope><name>BlockHeader</name></member>
      <member refid="classdsa_1_1e_alloc_1a01a9d3be9b919029d0d5bda73f56757c" prot="public" virt="non-virtual"><scope>dsa::eAlloc</scope><name>calloc</name></member>
      <member refid="classdsa_1_1e_alloc_1ad1f088a6a6ac5997e224ad0062c70523" prot="public" virt="non-virtual"><scope>dsa::eAlloc</scope><name>check</name></member>
      <member refid="classdsa_1_1e_alloc_1a90897aee2f774c0dd1d4267465394cb5" prot="public" virt="non-virtual"><scope>dsa::eAlloc</scope><name>check_pool</name></member>
      <member refid="classdsa_1_1e_alloc_1acbf770d2d9ab8ceb8df2a935a82eea10" prot="public" virt="non-virtual"><scope>dsa::eAlloc</scope><name>Control</name></member>
      <member refid="classdsa_1_1e_alloc_1acede9859339f8409d85c7a14cd71f6f2" prot="private" virt="non-virtual"><scope>dsa::eAlloc</scope><name>control</name></member>
      <member refid="classdsa_1_1e_alloc_1a142ecbc514fb8d9618fee741dece6efc" prot="public" virt="non-virtual"><scope>dsa::eAlloc</scope><name>deallocate</name></member>
      <member refid="classdsa_1_1e_alloc_1aca9cba9a8b6174888e0774a6e9e92a36" prot="public" virt="non-virtual"><scope>dsa::eAlloc</scope><name>eAlloc</name></member>
      <member refid="classdsa_1_1e_alloc_1a6cf6ea0950ef6c2c4d496a92c4786282" prot="public" virt="non-virtual"><scope>dsa::eAlloc</scope><name>free</name></member>
      <member refid="classdsa_1_1e_alloc_1a024bc4fbaab369234c4569a36c15b300" prot="public" virt="non-virtual"><scope>dsa::eAlloc</scope><name>get_pool</name></member>
      <member refid="classdsa_1_1e_alloc_1a5db3dffebe3e135f6629a128177ffa9e" prot="private" virt="non-virtual"><scope>dsa::eAlloc</scope><name>initialised</name></member>
      <member refid="classdsa_1_1e_alloc_1a8dbde398ec79c50e4bec8cb34c237760" prot="public" virt="non-virtual"><scope>dsa::eAlloc</scope><name>integrity_walker</name></member>
      <member refid="classdsa_1_1e_alloc_1aa237d516ee699b332e8fb5985bb7e643" prot="private" virt="non-virtual"><scope>dsa::eAlloc</scope><name>lock_</name></member>
      <member refid="classdsa_1_1e_alloc_1ab6eca8ea2b15b265e560e88d938adec3" prot="public" virt="non-virtual"><scope>dsa::eAlloc</scope><name>logStorageReport</name></member>
      <member refid="classdsa_1_1e_alloc_1a5faaeb302c059421ca82cfc7db8e9879" prot="public" virt="non-virtual"><scope>dsa::eAlloc</scope><name>malloc</name></member>
      <member refid="classdsa_1_1e_alloc_1a00bb3a88d7fd0f8148deb3a0786a9d64" prot="public" virt="non-virtual"><scope>dsa::eAlloc</scope><name>MAX_POOL</name></member>
      <member refid="classdsa_1_1e_alloc_1ad55296e9a38ece48f061fd23b8fb1738" prot="public" virt="non-virtual"><scope>dsa::eAlloc</scope><name>memalign</name></member>
      <member refid="classdsa_1_1e_alloc_1a029fe4dad4712ad2f5137c5ec15c9449" prot="private" virt="non-virtual"><scope>dsa::eAlloc</scope><name>memory_pools</name></member>
      <member refid="classdsa_1_1e_alloc_1a814a2f70aa21ae4ecdb1caf09a368cbe" prot="private" virt="non-virtual"><scope>dsa::eAlloc</scope><name>pool_count</name></member>
      <member refid="classdsa_1_1e_alloc_1ab191339864ad951a9b4174ed766ad024" prot="private" virt="non-virtual"><scope>dsa::eAlloc</scope><name>pool_sizes</name></member>
      <member refid="classdsa_1_1e_alloc_1a56c8d1f3e2368a15361968596b335eeb" prot="public" virt="non-virtual"><scope>dsa::eAlloc</scope><name>realloc</name></member>
      <member refid="classdsa_1_1e_alloc_1a8d029b14252fb77d1c2d5311b483abda" prot="public" virt="non-virtual"><scope>dsa::eAlloc</scope><name>remove_pool</name></member>
      <member refid="classdsa_1_1e_alloc_1aabc4d2a1849719c8c1a136262ef7f681" prot="public" virt="non-virtual"><scope>dsa::eAlloc</scope><name>report</name></member>
      <member refid="classdsa_1_1e_alloc_1a97fb67f4bb3ca8802b00f51935f954b7" prot="public" virt="non-virtual"><scope>dsa::eAlloc</scope><name>setLock</name></member>
      <member refid="classdsa_1_1e_alloc_1ae788e9d3eb03abbd532ef5ce3477edab" prot="public" virt="non-virtual"><scope>dsa::eAlloc</scope><name>tlsf</name></member>
      <member refid="classdsa_1_1e_alloc_1a799fb29ed4b5e3d4ab9a69cef933576a" prot="private" virt="non-virtual"><scope>dsa::eAlloc</scope><name>walk_pool</name></member>
      <member refid="classdsa_1_1e_alloc_1a50adb94983befce215dcff2aecfab2f4" prot="public" virt="non-virtual"><scope>dsa::eAlloc</scope><name>Walker</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
